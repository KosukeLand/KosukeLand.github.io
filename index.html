<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>某SIerの技術備忘録</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="某SIerの技術備忘録">
<meta property="og:url" content="https://kosukeland.github.io/index.html">
<meta property="og:site_name" content="某SIerの技術備忘録">
<meta property="og:locale" content="ja">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="某SIerの技術備忘録">
  
    <link rel="alternate" href="/atom.xml" title="某SIerの技術備忘録" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">某SIerの技術備忘録</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSSフィード"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="検索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kosukeland.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-AWSで資産管理してみる2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/02/AWSで資産管理してみる2/" class="article-date">
  <time datetime="2020-01-02T09:00:00.000Z" itemprop="datePublished">2020-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/02/AWSで資産管理してみる2/">AWSで資産管理してみる#2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>明けましておめでとうございます．<br>本年も当ブログをどうぞよろしくお願いいたします．</p>
<p>最近，更新頻度が下がってきました．<br>サボり気味でダメですね．気合を入れて開発を続けていきます．<br>さて，今回は10月に記載した「<a href="https://kosukeland.github.io/2019/10/11/AWSで資産管理してみる1/">AWSで資産管理してみる#1</a>」の続編です．<br>それでは，いきましょう．</p>
<hr>
<h1 id="2-やりたいこと"><a href="#2-やりたいこと" class="headerlink" title="2. やりたいこと"></a>2. やりたいこと</h1><p>まずは，前回のおさらいです．<br>前回の記事では，証券会社から取得した資産情報をデータレイクに貯める処理まで記載しました．<br>資産情報の取得にはLambdaを利用し，取得したデータをS3に投げ込むことでデータの利活用を目指します．<br>取得したデータは日次ごとにファイルに記載し，とりあえず日次ファイルは以下のフォーマットとしました．<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"保有資産評価"</span>: &#123;</span><br><span class="line">        <span class="attr">"現金残高等"</span>: <span class="number">10000</span>,</span><br><span class="line">        <span class="attr">"株式"</span>: <span class="number">20000</span>,</span><br><span class="line">        <span class="attr">"投資信託"</span>: <span class="number">30000</span>,</span><br><span class="line">        <span class="attr">"計"</span>: <span class="number">60000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"株式"</span>:&#123;</span><br><span class="line">         <span class="attr">"株式会社xxx"</span>: &#123;</span><br><span class="line">            <span class="attr">"保有株数"</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="attr">"取得単価"</span>: <span class="number">200</span>,</span><br><span class="line">            <span class="attr">"現在値"</span>: <span class="number">300</span>,</span><br><span class="line">            <span class="attr">"評価損益"</span>: <span class="number">10000</span></span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="attr">"株式会社yyy"</span>: &#123;</span><br><span class="line">            <span class="attr">"保有株数"</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="attr">"取得単価"</span>: <span class="number">200</span>,</span><br><span class="line">            <span class="attr">"現在値"</span>: <span class="number">300</span>,</span><br><span class="line">            <span class="attr">"評価損益"</span>: <span class="number">10000</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"投資信託"</span>:&#123;</span><br><span class="line">        <span class="attr">"日経225連動型"</span>: &#123;</span><br><span class="line">            <span class="attr">"保有口数"</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="attr">"取得単価"</span>: <span class="number">200</span>,</span><br><span class="line">            <span class="attr">"基準価額"</span>: <span class="number">300</span>,</span><br><span class="line">            <span class="attr">"評価損益"</span>: <span class="number">10000</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>また，上記のjsonファイルを用いて，以下の項目を見える化したいと考えました．<br>・現金，株式，投資信託ごとの資産額の推移<br>・個別銘柄ごとの資産額の推移</p>
<p>以上が前回のブログ記載時に実施したこと 及び 考えていたことです．</p>
<p>さて，，，S3に保存したデータを利活用するために，データの見える化をします．<br>フロントエンドにBIツールを利用することを考え，BIツールと連携しやすいDWHにデータをインポートする必要がありそうです．<br>また，個人開発なのでコストはなるべく抑える必要があります．<br>QCDでいうと，圧倒的にCが大事です．</p>
<p>上記の元，AWS上で構築する上で候補になったのは以下の2つ．</p>
<ol>
<li>Athena + QuickSight</li>
<li>ElasticSearch + Kibana</li>
</ol>
<p>BIツールは世の中に腐るほどあるのですが(本当か？)，<br>AWSを基盤として気軽にデータ解析をしようとすると，この2パターンがいいのかなと(マネージドサービスですしw)<br>さて，比較します．</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Athena + QuickSight</th>
<th style="text-align:left">ElasticSearch Service + Kibana</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">コスト</td>
<td style="text-align:left">1ユーザで利用する場合，ほぼタダ</td>
<td style="text-align:left">microインスタンスを利用して$13.5/month</td>
</tr>
<tr>
<td style="text-align:left">セキュリティ</td>
<td style="text-align:left">QuickSightの機能で認証認可　　</td>
<td style="text-align:left">Kibanaをインターネットに晒す場合，Cognito等を併用して認証認可？</td>
</tr>
<tr>
<td style="text-align:left">速度</td>
<td style="text-align:left">何もわからない</td>
<td style="text-align:left">何もわからない</td>
</tr>
<tr>
<td style="text-align:left">運用</td>
<td style="text-align:left">マネージドサービスなので運用不要</td>
<td style="text-align:left">ElasticSearchの運用等(バージョンアップとか)はユーザ責任</td>
</tr>
</tbody>
</table>
<p>ということで，コストを優先して今回はAthena + QuickSightを採用します．<br>ちなみに，上記の「1ユーザでAthena + QuickSight利用する場合，ほぼタダ」というのは，<br> ・Athenaは1TBのスキャン当たり$5必要なのに対して，自身がS3に保存しているデータは10MB以下なので，スキャン費用もほぼタダ<br> ・QuickSightは1ユーザ無料特典がついているため，費用は掛からず利用ができる(<a href="https://aws.amazon.com/jp/quicksight/pricing/" target="_blank" rel="noopener">参考</a>)<br>という意味です．</p>
<p>さて，構成図はこんな感じになります．<br>S3のjsonファイルをAthenaを用いてスキャンし，その結果をQuickSightで表示します(Lambda, S3の構成は前回のブログと同様)．</p>
<p><img src="/images/20200102-1.png" alt="図1: 構成図" title="図1: 構成図" width="600"></p>
<p>さて，実装です(AthenaとQuickSightの使い方は，まとめてくださっている方々がいるので割愛)．<br>S3に保存したデータをAthenaで利用するために，データカタログを作ろうとしたところうまくできず．．．．<br>理由としてはjsonがネストしていたからなのですが，それ以外にも2byte文字(記号とかスペースとか)がjson内に存在したりと問題がありそうなので，jsonファイルを整形します．こんな感じに．<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"日時"</span>: <span class="string">"20xx-xx-xx"</span>, <span class="attr">"銘柄"</span>: <span class="string">"xxxx"</span>, <span class="attr">"保有株数"</span>: <span class="number">100</span>, <span class="attr">"取得単価"</span>: <span class="number">200</span>, <span class="attr">"現在値"</span>: <span class="number">300</span>, <span class="attr">"資産額"</span>: <span class="number">30000</span>, <span class="attr">"評価損益"</span>: <span class="number">10000</span>&#125;</span><br><span class="line">&#123;<span class="attr">"日時"</span>: <span class="string">"20xx-xx-xx"</span>, <span class="attr">"銘柄"</span>: <span class="string">"yyyy"</span>, <span class="attr">"保有株数"</span>: <span class="number">200</span>, <span class="attr">"取得単価"</span>: <span class="number">200</span>, <span class="attr">"現在値"</span>: <span class="number">300</span>, <span class="attr">"資産額"</span>: <span class="number">60000</span>, <span class="attr">"評価損益"</span>: <span class="number">20000</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>整形前のjsonには，総資産および株式，投資信託の情報全てが記載されていました．<br>しかし，それだとデータカタログを綺麗に作れそうにないので，各々(総資産と株式と投資信託)を1jsonファイルずつに分割しました．<br>銘柄には証券コードを記載し，2byte文字(記号とかスペースとか)の混入を防いでいます．<br>また，いろいろ試してわかったのですが，Athenaのパーサは括弧(“{“)と括弧(“}”)の間に改行を含めると<br>うまくいかないようなので，括弧内の全ての改行を消去しました(<a href="https://dev.classmethod.jp/cloud/aws/athena-json/" target="_blank" rel="noopener">参考</a>)</p>
<p>AthenaはHive？ベースのSQLらしく，ちょっと癖があるとのこと．．．(あまりよく分かってない)<br>テーブルを全表示させるために下記のようにSQLを書くらしいが，最終的にQuickSightからSQLを発行するはずなので気にしない．<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">"asset"</span>.<span class="string">"sum"</span>;</span><br></pre></td></tr></table></figure></p>
<p>AthenaでSQLが発行できたら，最後にQuickSightの設定をします．<br>QuickSight自体はユーザを登録し，データソースをインポートすればすぐに利用できるのだが，<br>QuickSightからデータファイル(json)が入っているS3のバケットへのReadを有効にしないと，以下のエラーが発生します．<br>この点は要注意．</p>
<p><img src="/images/20200102-2.png" alt="図2: QuickSightエラー" title="図2: QuickSightエラー" width="600"></p>
<hr>
<h1 id="3-おわりに"><a href="#3-おわりに" class="headerlink" title="3. おわりに"></a>3. おわりに</h1><p>これで，資産の見える化がある程度できました．<br>とりあえずは数ヶ月間利用してみて，改善点を洗い出そうかな．<br>あとCI/CD… そろそろなんとかしないと…</p>
<hr>
<h1 id="4-余談"><a href="#4-余談" class="headerlink" title="4. 余談"></a>4. 余談</h1><h2 id="4-1-コードの公開して"><a href="#4-1-コードの公開して" class="headerlink" title="4.1. コードの公開して"></a>4.1. コードの公開して</h2><p>Githubで公開できる様，準備しております．<br>少々，お待ちください．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2020/01/02/AWSで資産管理してみる2/" data-id="ck4wmoygb0014mbuyhjxf306d" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AWS/">AWS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ライフハック/">ライフハック</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-婚活サイトから更新情報取得するライフハック" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/26/婚活サイトから更新情報取得するライフハック/" class="article-date">
  <time datetime="2019-10-26T11:00:00.000Z" itemprop="datePublished">2019-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/26/婚活サイトから更新情報取得するライフハック/">婚活サイトから更新情報取得するライフハック</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>こんにちは．筆者です．今回もライフハック記事を書きました．<br>それではいきましょう！</p>
<hr>
<h1 id="2-やりたいこと"><a href="#2-やりたいこと" class="headerlink" title="2. やりたいこと"></a>2. やりたいこと</h1><p>恥ずかしながら当方30歳を超えておりますが結婚する予定もなく，昨年より婚活サイトに登録して日々活動しているわけです．<br>しかし，私が利用しているサイトはWebページのみでアプリはなく，色々と不便なことが多いです．<br>一番辛いのは，プッシュ機能がないこと．<br>サイト内の情報が更新されても，気付かないなんてこともありますし，<br>更新の有無を求めてリロードを繰り返し，通信制限に引っかかってしまうなんてことも増えてきました(ちょっと大袈裟)．<br>なんとかせねば．．．．</p>
<p>ということで，定期的に婚活サイトにhttpリクエストを飛ばして，更新をチェックする仕組みを作ることにしました．</p>
<hr>
<h1 id="3-アーキテクチャ"><a href="#3-アーキテクチャ" class="headerlink" title="3. アーキテクチャ"></a>3. アーキテクチャ</h1><p>まず，どの基盤でシステムを作るかですが，，，AWS大好きなので今回もAWSを使います(自宅サーバなんて論外♡)．<br>前回同様，お金ないので全部サーバレスで実装し，運用は私が困らない程度の作り込みになります．<br>正直，運用についてはあまり考えられていません．ご承知おきください．</p>
<p>さて，今回のアーキテクチャはこちら．<br><img src="/images/20191026-1.png" alt="図1: アーキテクチャ" title="図1: アーキテクチャ" width="600"><br>図内の数字は，機能の実行順を表します．詳細を見ていきましょう．<br>私の要件を満たすためには，次の3つのステップが必要になります．</p>
<ol>
<li>婚活サイトへGetリクエストを飛ばして，結果をHTMLファイルとしてS3のNewバケットに保存</li>
<li>NewバケットのHTMLとOldバケットのHTMLを比較して差分の有無をチェック．差分があったら通知．</li>
<li>NewバケットのHTMLをOldバケットに移動</li>
</ol>
<p>それぞれの機能をLambdaで動かします．<br>1機能当たり2秒から10秒前後で完了するため，コンテナをわざわざ利用する必要はありません．Lambdaで十分！<br>まず，CloudWatchEventのCron機能を利用して定期的にシステムを起動させます．<br>起動タイミングはお好みだとは思いますが，起動間隔はある程度空けるようにしましょう．DoSと認識されてしまいます．</p>
<p>次に，情報を取得するGetリクエストを飛ばすためにpythonのrequestsライブラリを利用しました．<br>おそらくpythonでhttpリクエストをする際に最も使われるライブラリだと思います．<br>使い方はとても簡単で，Getリクエストを送る際は以下を記述するだけです．<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">html = requests.session().get(URL)</span><br></pre></td></tr></table></figure></p>
<p>ちなみに，S3へのGet/Putリクエストにはboto3ライブラリを利用しています．これは前回の記事と同様かな．</p>
<p>差分が発生した際の通知先ですが少し悩みました．勉強のためにSNS使ってメール通知とするか，Slack通知とするか．．．<br>ウンウン悩んだ結果，，使い慣れたLineでいっか！  って感じでLineになりました．<br>Lineに通知するために，LineDevelopersよりMessagingAPIを作成してAWSから当該APIをキックすることで実現しました．<br>MessagingAPIをキックするためには，<a href="https://github.com/line/line-bot-sdk-python" target="_blank" rel="noopener">LineBotApi及びTextSendMessageライブラリ</a>を利用します，<br>当該API経由でLineに通知するコードはこんな感じ．<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> linebot <span class="keyword">import</span> LineBotApi</span><br><span class="line"><span class="keyword">from</span> linebot.models <span class="keyword">import</span> TextSendMessage</span><br><span class="line">message = TextSendMessage(text=<span class="string">f"更新がありました"</span>)</span><br><span class="line">LineBotApi(LINE_ACCESS_TOKEN).push_message(USER_ID,messages=message)</span><br></pre></td></tr></table></figure></p>
<p>USER_IDとLINE_ACCESS_TOKENは．MessagingAPI作成後に取得でき，これを利用してAPIをキックします．<br>これで，「更新がありました」と通知されます．</p>
<p>最後になりますが，これら一連の流れを管理するためにAWS Stepfunctionsを利用しました．<br>AWS Stepfunctionsはジョブの実行順，分岐，待ち合わせ等を定義し，ジョブをコントロールするためのサービスです．<br>今回は，Lambdaの繋ぎをAWS Stepfunctions実現しています．<br>AWS Stepfunctionの設定については別途ブログに書こうかな．</p>
<hr>
<h1 id="4-おわりに"><a href="#4-おわりに" class="headerlink" title="4. おわりに"></a>4. おわりに</h1><p>婚活ライフハックをしてみました．<br>ライフハックしたからといって，結婚に近くという訳ではありませんが，<br>生活を便利にするために改善をすることは好きなので，今後も続けていきます．</p>
<hr>
<h1 id="5-余談"><a href="#5-余談" class="headerlink" title="5. 余談"></a>5. 余談</h1><h2 id="5-1-差分チェックはHTMLを比較するだけか？"><a href="#5-1-差分チェックはHTMLを比較するだけか？" class="headerlink" title="5.1. 差分チェックはHTMLを比較するだけか？"></a>5.1. 差分チェックはHTMLを比較するだけか？</h2><p>いいえ違います．<br>Getリクエストの戻り値には，リクエストごとにvalueが異なる箇所がありました(婚活サイトの仕様？)．<br>これでは常に差分が発生し，狼少年になってしまいます．<br>そのためHTML全体を比較することはやめて，必要な箇所のみ差分を取得するようにしました．<br>必要な箇所を取得するために，ちょっとだけスクレイピングをしております．ライブラリはBeautifulSoupです．</p>
<h2 id="5-2-例外処理はしているのか？"><a href="#5-2-例外処理はしているのか？" class="headerlink" title="5.2. 例外処理はしているのか？"></a>5.2. 例外処理はしているのか？</h2><p>してません．<br>そして，機能1がタイムアウトするとシステムがバグるのを確認しています．<br>例えば，婚活サイトがダウンしていた際がこれに当たります．<br>しかし，個人開発なのであまり凝ったことをするつもりはありません．</p>
<p>余談ですが，上記のシステムでは機能1の実行時間が長いです．5秒から10秒程度かかります．<br>時間の大部分を占めているのはGetリクエストで，おそらく婚活サイトのWebサーバが遅いためと考えられます．<br>そのため，Lambdaのタイムアウト時間を20秒程度にしております(これでバグらない)．<br>本来ならタイムアウトした場合を考慮して実装すべきなのですが，今回は目を瞑っています．</p>
<h2 id="5-4-月々のキャッシュアウトは？"><a href="#5-4-月々のキャッシュアウトは？" class="headerlink" title="5.4. 月々のキャッシュアウトは？"></a>5.4. 月々のキャッシュアウトは？</h2><p>イニシャルコストは0円でした．私の労働力だけです．<br>月々のランニングコストは今のところ不明ですが，数円程度必要になると思います(S3のPut回数の無料枠が2000回/月なので)．</p>
<h2 id="5-3-開発について"><a href="#5-3-開発について" class="headerlink" title="5.3. 開発について"></a>5.3. 開発について</h2><p>ローカルのDocker環境で開発しています．<br>プログラムが完成したらLambdaにデプロイするのですが，デプロイが辛すぎて泣きそうです．<br>なぜなら，必要なライブラリをzipに固めてアップロードする必要があるから！マネジメントコンソールを使ってアップロードしているから！<br>これは，本当になんとかしたい！！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/10/26/婚活サイトから更新情報取得するライフハック/" data-id="ck4wmoyg3000kmbuy9y4vuuz6" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AWS/">AWS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ライフハック/">ライフハック</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AWSで資産管理してみる1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/11/AWSで資産管理してみる1/" class="article-date">
  <time datetime="2019-10-11T13:00:00.000Z" itemprop="datePublished">2019-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/11/AWSで資産管理してみる1/">AWSで資産管理してみる#1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>お久しぶりです．更新するのは久々です．<br>今日はAWSを使ってライフハックしたので，備忘録として載せておきます．<br>それでは，いきましょう．</p>
<hr>
<h1 id="2-やりたいこと"><a href="#2-やりたいこと" class="headerlink" title="2. やりたいこと"></a>2. やりたいこと</h1><p>当方，株式投資に興味を持ち数年前よりちょいちょい株式を買っております．<br>毎日，証券会社のコンソールで利益率を確認しておりますが，確認できるのは持ち株の利益率のみで<br>株式投資を始めてから現在までのトータルとしてどの程度利益や損失が出たのか確認する術はありません．<br>株はもちろん売買しますし，売った利益はコンソール上には反映されません．<br>そこで以下の項目を見える化し，トータルでどの程度利益を出したか把握できる環境を構築します．<br>・現金，株式，投資信託ごとの資産額の推移<br>・個別銘柄ごとの資産額の推移</p>
<hr>
<h1 id="3-アーキテクチャ"><a href="#3-アーキテクチャ" class="headerlink" title="3. アーキテクチャ"></a>3. アーキテクチャ</h1><p>証券会社のサイトから自身の資産情報をキャッチして，それをストレージに保管するため<br>こんな感じのアーキテクチャを考えてみました．</p>
<p><img src="/images/20191011-1.png" alt="図1: アーキテクチャ" title="図1: アーキテクチャ" width="600"></p>
<p>証券会社から情報を取得するために，AWSのLambdaでコードを実行します．<br>Lambdaでキャッチした情報は，JSON形式に変換してS3へ保存することで永続化します．<br>資産を見える化するためにはBIツール等を利用する必要がありますが，それについては現在検討中です．<br>後日ブログで紹介できたらなーと考えております．</p>
<p>さて，図の数字に沿って細かく説明していきます．<br>まず，CloudWatchEventsがLambdaをキックすることで，システムが動きます．<br>私の投資先は投資信託が中心であり，基準価格が更新されるタイミングは1日1回のためLambdaをキックするのも1日1回で十分です．<br>手動でLambdaを実行するのは辛いので，LambdaのキックをCloudWatchEventsに任せます．<br>CloudWatchEventsの設定に関しては，<a href="https://docs.aws.amazon.com/ja_jp/AmazonCloudWatch/latest/events/ScheduledEvents.html" target="_blank" rel="noopener">こちら</a>が参考になります．<br>また，CloudWatchEventsのCronを利用する際の注意なのですが，<br>本機能は世界標準時を利用しているため，日本の場合，設定時間は”-9時間”する必要があります．</p>
<p>次に，Lambdaで証券会社より情報を取得するのですが，おそらくアクセスする際はUSERIDとPASSが必要となると思います．<br>これらは，ソースコードに記載の無いようご注意ください(GitHub等外部リポジトリにpushすることを考えて)．<br>Lambdaの環境変数として定義することをオススメします．</p>
<p><img src="/images/20191011-2.png" alt="図2: 環境変数" title="図2: 環境変数" width="600"></p>
<p>最後に取得したデータをS3に格納するのですが，私はSDKを利用しました．<br>資産データをJSON形式でLambdaの/tmpにファイルを吐き出した後，当該ファイルをS3へ転送しております．<br>実はLambdaは/tmp以下にファイルを保存することができるのです．Lambda実行後に削除されてしましますが，，，</p>
<hr>
<h1 id="4-おわりに"><a href="#4-おわりに" class="headerlink" title="4. おわりに"></a>4. おわりに</h1><p>自身の資産データをS3に保存することはできるようになりました．<br>次にやるべきこととして，以下を考えております．</p>
<ol>
<li>データの見える化 (BIツールの導入)</li>
<li>デプロイの自動化(CI/CD)</li>
</ol>
<p>イケてるBIツール，CI/CDツール教えてください！！！</p>
<hr>
<h1 id="5-余談"><a href="#5-余談" class="headerlink" title="5. 余談"></a>5. 余談</h1><h2 id="5-1-なんで，自宅サーバにしなかったのか？"><a href="#5-1-なんで，自宅サーバにしなかったのか？" class="headerlink" title="5.1. なんで，自宅サーバにしなかったのか？"></a>5.1. なんで，自宅サーバにしなかったのか？</h2><p>昔，RaspberryPiを自宅サーバとして運用しておりましたが辞めました．<br>理由はいくつかありますが，一番は火事が怖いからです．<br>自宅サーバで火事になったことも，友人宅で火事が発生したこともありませんが，<br>火事になったら近隣住人にまで影響がでてしまうため，リスクを回避することにしました．</p>
<h2 id="5-2-Lambdaが最適か？"><a href="#5-2-Lambdaが最適か？" class="headerlink" title="5.2. Lambdaが最適か？"></a>5.2. Lambdaが最適か？</h2><p>当方，クラウドはAWSしかわかりません．なので，AWSのサービスから選びました．<br>AWSの数あるサービスの中でLambdaを利用した理由は，作成したスクリプト実行時間が3秒以下で実行回数が1回/日だからです．<br>最近Dockerを触ることが多いのでFargateも検討しましたが，3秒の実行のためにECRからイメージを吸い出して展開するのは<br>あまりにもリッチすぎると結論づけました．<br>たしか実行時間が15分を超える場合，Lambdaを利用することはできないはずなので<br>長時間のバッチ等を動かす際は，Fargateも検討したいと思います(AWS Batchの方が良いのか？)．</p>
<h2 id="5-3-LambdaはVPC内に配置することもできたよね？"><a href="#5-3-LambdaはVPC内に配置することもできたよね？" class="headerlink" title="5.3. LambdaはVPC内に配置することもできたよね？"></a>5.3. LambdaはVPC内に配置することもできたよね？</h2><p>LambdaはVPC内に入れることも可能ですが運用コストが増加するため，今回は非VPCとしております．<br>(LambdaをVPC内に入れると，IP管理等のコストが増えます)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/10/11/AWSで資産管理してみる1/" data-id="ck4wmoyfk0000mbuyzpq5su23" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AWS/">AWS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ライフハック/">ライフハック</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-桁DP実装したった" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/22/桁DP実装したった/" class="article-date">
  <time datetime="2019-06-22T14:00:00.000Z" itemprop="datePublished">2019-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/22/桁DP実装したった/">桁DP実装したった</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>今日は久しぶりにDPネタを扱ってみようと思います．<br>DPネタで有名なのはナップサック問題ですが，経路探索もDPですし，LCSと呼ばれる文字列探索DPもあります．<br>DPは奥が深いのです！！<br>そんな奥が深いDPのなかで，今日は桁DPを扱います．<br>それでは行ってみましょー！！</p>
<p>最近，筆者のメイン言語がJavaScriptからGolangに変わりました．<br>今後，コードの書き方がGolangライクになるかと思いますが，ご了承下さいm(_ _)m</p>
<hr>
<h1 id="2-桁DPの考え方-および-実装"><a href="#2-桁DPの考え方-および-実装" class="headerlink" title="2. 桁DPの考え方 および 実装"></a>2. 桁DPの考え方 および 実装</h1><p>桁DPとは，複数の数字列に対して特定の数字の出現回数をカウントする場合に利用するアルゴリズムです．<br>以下の具体例を見ながら，勉強していきましょう．</p>
<p>1から順に9876まで書き出した際に，「1」を書く回数を調査<br>(例えば，1から12を記載する場合，1が出現するのは1,10,11,12であり，1の記載回数は5)</p>
<p>まずは，ナイーブなアルゴリズムから記載します．<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数値Nの桁ごとの数字のカウント</span></span><br><span class="line">N = <span class="number">9876</span>; x = <span class="number">1</span>;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">    <span class="comment">// 桁ごとに数字を分割</span></span><br><span class="line">    z = i.split()</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; z.length ; j++)&#123;</span><br><span class="line">        <span class="comment">// i桁目の数字がxなら，ans++</span></span><br><span class="line">        <span class="keyword">if</span>(z[j] == x)&#123; ans++ &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>この場合，1から9876までの数字列の各桁を参照し，それが「1」と一致するか判定することで「1」の記載回数を探索しています．<br>したがって，計算量はO(N^2)となります．</p>
<p>ただしこのプログラムは，<br>「桁ごとの数字が異なっていても1の出現回数が同一であれば，同一箇所を複数回計算する必要はない」<br>という理由で無駄が多いと言えます．<br>少し分かりづらいですよね．詳細を説明します．<br>例えば，12010と12058のように一致している桁がある場合(この場合は，上位3桁が一致している)，<br>一致箇所の結果を記憶しておくことで，複数回探索する必要はないことはすぐ分かると思います．<br>つまり，「120では1は1回しか記述しない」と記憶しておくことで，12001は120で1は1回，10で1が1回　合わせて2回とできそうです．</p>
<p>しかし，さらに計算量を削減できることに気付きます．<br>なぜなら，今回重要な情報は1の出現回数であり，各桁の数字が一致しているかどうかは1の出現回数に影響がないからです．<br>例えば，1321と1541のような上位3桁は異なっていたとしても，1の出現回数は同じならば，それぞれを個別に考慮する必要はありません．<br>同一の状況として記憶すれば良いのです．</p>
<p>では，上記のアルゴリズムでプログラムを書いていきましょう．</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数値Nの桁ごとの数字のカウント</span></span><br><span class="line">N = <span class="number">9876</span>; x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">memo = [][][]</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// k: 現在探索している桁数(上位から数えてk桁目)</span></span><br><span class="line"><span class="comment">// tight: 上位から数えてk桁目の取りうる値の範囲を示すフラグ trueの場合，k桁目の取りうる値の範囲が制限される</span></span><br><span class="line"><span class="comment">// sum:  1が出現した回数をカウント</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">k, tight, sum</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 入力が一致していたら，メモ化(図1:条件3)</span></span><br><span class="line">    <span class="keyword">if</span>(memo[k][tight][sum]) &#123; <span class="keyword">return</span> (memo[k][tight][sum]) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// k桁目がN.lengthと一致したら終了</span></span><br><span class="line">    <span class="keyword">if</span>(k === N.length)&#123; <span class="keyword">return</span> (sum); &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment">// k桁目が取りうる値の範囲(図1:条件2)</span></span><br><span class="line">        r = (tight ? N[k] : <span class="number">9</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="comment">//k桁目がxならば(図1:条件1)</span></span><br><span class="line">            <span class="keyword">if</span>(i == x)&#123; res += dfs(k + <span class="number">1</span>,(tight &amp;&amp; i == r), sum + <span class="number">1</span>); &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; res += dfs(k + <span class="number">1</span>,(tight &amp;&amp; i == r), sum); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 結果を記憶し再利用</span></span><br><span class="line">        memo[k][tight][sum] = res;</span><br><span class="line">        <span class="keyword">return</span>(memo[k][tight][sum])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再帰関数で記載する方が好みであるので，このように記載しました(まぁ，桁DPの解説はほぼメモ化使ってる気がするが．．)．<br>本プログラムは図1の条件1，条件2，条件3をもとに計算しています．<br>kが検索対象である1と同一であれば合計値を加算し，加えて条件2，条件3を適用することで，検索対象を絞っています．<br><img src="/images/20190622-1.png" alt="図1: 桁DPの考え方" title="図1: 桁DPの考え方" width="700"></p>
<hr>
<h1 id="3-おわりに"><a href="#3-おわりに" class="headerlink" title="3. おわりに"></a>3. おわりに</h1><p>今日は，桁DPについてふれていきました．<br>AtCoderでも桁DP問題があるので，解いて理解を深めていきましょう．<br>それではーノシ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/06/22/桁DP実装したった/" data-id="ck4wmoyg7000umbuywflfuphg" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DP/">DP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/アルゴリズム/">アルゴリズム</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-最短経路問題を解く" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/07/最短経路問題を解く/" class="article-date">
  <time datetime="2019-05-07T13:00:00.000Z" itemprop="datePublished">2019-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/07/最短経路問題を解く/">最短経路問題を解く</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>競技プログラミングにおいて，最短経路探索を問われるケースは多々あります．<br>以前より，興味があった分野であるため少し勉強してみました．<br>今日は，代表的なアルゴリズムである，ワーシャルフロイド法とダイクストラ法を解説していきます．<br>それではいきましょう！</p>
<hr>
<h1 id="2-ワーシャルフロイド法"><a href="#2-ワーシャルフロイド法" class="headerlink" title="2. ワーシャルフロイド法"></a>2. ワーシャルフロイド法</h1><p>ワーシャルフロイド法の方がダイクストラ法に比べて平易であり理解が進むと思うため，こちらを先に記載しています．<br>ワーシャルフロイド法では，ノードkを経由してノードiからノードjへ移動する最小コストを更新していきます．<br>計算量はO(V^3)と少し重めですが，全てのノード間の最短経路を計算できるため有用です．<br>図を利用して説明しましょう．</p>
<p><img src="/images/20190507-1.png" alt="図1: ワーシャルフロイド法解説" title="図1: ワーシャルフロイド法解説" width="500"></p>
<p>図中の丸はノードを 線はノード間の接続を表し，線上に記載された値はノード移動の際に発生するコストを表します．<br>ワーシャルフロイド法では全ノード間の最短経路を探索するため，本来は全てのノードの探索を説明する必要があるのですが，<br>ここでは，ノードAからノードEへの最小コストにのみに着目し説明したいと思います．<br>まず，図よりノードAはノードBと接続しているため，ノードBを経由すればノードEへ到達できそうです．<br>その際のコストは15(5+10)となります．現在の最小コストとなります(青)．<br>次にノードAからノードBを経由してノードDへ到達した場合のコスト9(5+4)を記憶します(赤)．<br>最後にノードAからノードDを経由してノードE到達した場合，コストは13(9+4)となるため，最小コストが更新されます(赤)．</p>
<p>このようにして最短経路を更新し続け，最終的に出力される経路が最短となります．<br>では，実装してみましょう．<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配列dをコストで初期化</span></span><br><span class="line"><span class="comment">// d[start][goal] = cost;</span></span><br><span class="line"></span><br><span class="line">V = ノード数</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中継ノード</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span> ; k = V ; k++)&#123;</span><br><span class="line">    <span class="comment">// スタートノード    </span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i = V ; i++)&#123;</span><br><span class="line">        <span class="comment">// ゴールノード</span></span><br><span class="line">        <span class="keyword">for</span>(j) = <span class="number">0</span> ; j = V ; j++)&#123;</span><br><span class="line">            d[i][j] = Min(d[i][j], d[i][k] + d[k][j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上記の通り，アルゴリズムが非常に平易であるため，計算量的に厳しくなければワーシャルフロイドを利用することが良いでしょう．<br>AtCoderの場合，ノード数が10^2以内であれば間に合いそうです．<br>それ以上になると，計算量を落としたアルゴリズムを利用する必要があります．</p>
<hr>
<h1 id="3-ダイクストラ法"><a href="#3-ダイクストラ法" class="headerlink" title="3. ダイクストラ法"></a>3. ダイクストラ法</h1><p>インプットが少なければ，ワーシャルフロイド法で良いのですが，<br>インプットが大きい場合(例えば，ノードが10^3を超える場合)はダイクストラ法を利用することになるでしょう．<br>ダイクストラ法では，特定のスタートノードからの最短経路が確定していないノードに着目し，当該ノードの最短経路を確定させ続けることでスタートノードからゴールノードへの最短経路を確定させます．</p>
<p><img src="/images/20190507-2.png" alt="図2: ダイクストラ法解説-1" title="図2: ダイクストラ法解説-1" width="500"></p>
<p>ワーシャルフロイド法と同様にノードAからノードEへの最短経路を探索します．<br>まず，ノードAより移動可能なノードBのみなのでノードBへの最短経路は5と確定します．</p>
<p><img src="/images/20190507-3.png" alt="図3: ダイクストラ法解説-2" title="図3: ダイクストラ法解説-2" width="500"></p>
<p>次にノードBより移動可能なノードは，ノードC，ノードD，ノードEなので それぞれのノードへの移動コストを計算します．<br>計算すると12，9，15とわかります．<br>この中でノードDへ移動コストはこの中で最小の9であるため，ノードAからノードDへの移動の最小コストであるとわかります．</p>
<p><img src="/images/20190507-4.png" alt="図4: ダイクストラ法解説-3" title="図4: ダイクストラ法解説-3" width="500"></p>
<p>最後に，ノードDから移動可能なノードEであり，その距離は4であることが図からわかります．<br>そのため，ノードAからノードEへの最小コストは13であるとわかります．</p>
<p>さて，ダイクストラ法も実装してみましょう．</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配列costをコストで初期化</span></span><br><span class="line"><span class="comment">// (インプットとしてコストが与えられない場合，そのコストはInfinity)</span></span><br><span class="line"><span class="comment">// cost[start][goal] = cost;</span></span><br><span class="line"></span><br><span class="line">V = ノード数</span><br><span class="line">used[] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// スタート地点まで到達するためのコストは0</span></span><br><span class="line">d[start] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    v = <span class="number">-1</span> ;</span><br><span class="line">    <span class="comment">// 最短経路が確定していないノードの中で，現在スタート地点からの距離が最短のノードを探索</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[i] &amp;&amp; (v == <span class="number">-1</span> || d[i] &lt; d[v]))&#123; </span><br><span class="line">            v = i;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用フラグ立てる</span></span><br><span class="line">    used[i] = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ノードを全て利用している場合，ループ終了</span></span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">-1</span>)&#123; <span class="keyword">break</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 現在のノードvまでのコスト と ノードiまでのコストとノードiからノードvへのコストの合計 の小さい方を選択</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line">        d[v] = Min(d[v], d[i] + cost[i][v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分集合の解を計算することで目的の値を取得することから，本アルゴリズムは計算動的計画法と言えると思います．<br>またダイクストラ法では，最短経路が確定した際に経路を記憶することで，スタートノードからゴールノードまでの経路情報を生成することも可能です．</p>
<hr>
<h1 id="4-おわりに"><a href="#4-おわりに" class="headerlink" title="4. おわりに"></a>4. おわりに</h1><p>今日は経路探索アルゴリズムをみていきました．<br>実は，有名なアルゴリズムとしてベルマンフォード法もあるのですが，<br>負の閉路が存在するグラフ以外適用されないアルゴリズムであり，基本的に上記の2つの学習優先度の方が高いと判断しました．<br>良ければ学んでみてください．<br>それでは！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/05/07/最短経路問題を解く/" data-id="ck4wmoyg5000pmbuyosh6e1ze" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/アルゴリズム/">アルゴリズム</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/競技プログラミング/">競技プログラミング</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Dockerネットワークについて" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/01/Dockerネットワークについて/" class="article-date">
  <time datetime="2019-05-01T13:00:00.000Z" itemprop="datePublished">2019-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/01/Dockerネットワークについて/">Dockerネットワークについて</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>簡単な検証をすることが最近多いのですが，その際にDockerを触ることが多くなりました．<br>多くのプロダクトがDockerHubより提供されているため，簡単な検証環境を構築する際にDockerは大変便利です．<br>特に私の場合ローカルのPCスペックがそこまで良くないので，複数台のマシン(or 仮想マシン)を使った検証をすることができず<br>必然的にDockerを利用して検証環境を作ることになります．<br>これだけ世間で流行る理由がよくわかります．もう検証環境を構築するために仮想マシン立てることはできないでしょう．<br>めんどくさいですしw</p>
<p>さて，今日はDockerの中でもネットワークに関して，少し触れていきたいと思います．</p>
<hr>
<h1 id="2-Dockerネットワーク概要"><a href="#2-Dockerネットワーク概要" class="headerlink" title="2. Dockerネットワーク概要"></a>2. Dockerネットワーク概要</h1><p>Dockerコンテナを起動させると，コンテナに対しネットワークが割り当てられます．<br>特に設定していない場合は”bridge”が利用され，ホストマシンをブリッジして外部の環境と通信をすることになります．</p>
<p>しかし，Dockerネットワークにはbridge以外にも以下のネットワークがデフォルトで用意されています．</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">xxxxxxxxxxxx        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">yyyyyyyyyyyy        host                host                <span class="built_in">local</span></span><br><span class="line">zzzzzzzzzzzz        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<h2 id="2-1-bridgeネットワーク"><a href="#2-1-bridgeネットワーク" class="headerlink" title="2.1 bridgeネットワーク"></a>2.1 bridgeネットワーク</h2><p>docker0と呼ばれる仮想ブリッジ経由で通信する形式です．<br>各コンテナはveth(カーネルが提供するか仮想インターフェース)を介して仮想ブリッジに接続されます．<br>図で書くと以下のようになります．</p>
<p><img src="/images/20190501-1.png" alt="図1: bridgeネットワーク" title="図1: bridgeネットワーク" width="500"></p>
<p>コンテナはeth0というNICを認識し(実体はveth)，当該NICを利用してコンテナ同士 又は外部機器と通信します．<br>コンテナとホストマシンのネットワークは分離されているため，それぞれ異なるアドレスレンジを利用します．<br>なので，外部機器と通信する際はdocker0をデフォルトゲートウェイに利用し，そこでホストマシンのアドレスにNATされます．</p>
<p>ここで注意すべき点として，<br>コンテナはDockerが管理するアドレス空間から利用されていないIPアドレスが自動的に割り当てられるため，コンテナのIPは不定となります．<br>DHCPを想像していただければ分かりやすいかと思います．<br>コンテナに割り当てられるアドレスレンジの確認は，以下のコマンドで行います．</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect bridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"5482b53471090013ec6ec2605214545e595d713dede280e815dcc9efb0968458"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2019-05-01T12:40:10.365713105Z"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: null,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"172.17.0.0/16"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.17.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"ConfigFrom"</span>: &#123;</span><br><span class="line">            <span class="string">"Network"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ConfigOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"f1761e429f3c3b797ea6db3e9f7ceae43190a43b5186e9805e32e78b50e6f616"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"fuga"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"04815728bd8de73d69fe09b22f0f6b4feb61a5e609543b93731b336d0b8e54a9"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"172.17.0.2/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      :</span><br><span class="line">   〜省略〜</span><br><span class="line">      :</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>コマンドの結果を確認すると，コンテナには172.17.0.0/16のネットワークが割り当てられ<br>そのデフォルトゲートウェイは172.17.0.1であることがわかります．<br>また，コンテナには，172.17.0.2のアドレスが割り当てられていることも合わせて確認することができます．</p>
<h2 id="2-2-hostネットワーク"><a href="#2-2-hostネットワーク" class="headerlink" title="2.2 hostネットワーク"></a>2.2 hostネットワーク</h2><p>使ったことないので，軽めの説明です．<br>ホストマシンと同一のアドレスをコンテナで利用する際に本ネットワークを選択します．<br>図で書くと以下のような構成になります．</p>
<p><img src="/images/20190501-2.png" alt="図2: hostネットワーク" title="図2: hostネットワーク" width="500"></p>
<p>hostネットワークに所属する全てのコンテナがホストマシンと同一のアドレスとなるため，<br>通信する際はポートを指定することになります(なるはず)．<br>そのため，利用用途は限られるのではないかと考えています．</p>
<p>※ hostネットワークは，Docker Desktop for Mac 及び Docker Desktop for Windowsで未サポートです．<br><a href="https://docs.docker.com/network/host/" target="_blank" rel="noopener">https://docs.docker.com/network/host/</a></p>
<h2 id="2-2-noneネットワーク"><a href="#2-2-noneネットワーク" class="headerlink" title="2.2 noneネットワーク"></a>2.2 noneネットワーク</h2><p>このネットワークも使ったことないので，軽めの説明です．<br>公式ドキュメントに，「全てのネットワークがdisableになる」と記載があるため，<br>任意のコンテナが他のコンテナ 及び 外部と通信しない場合，本ネットワークを選択します．<br>図で書くと以下のような構成になります(と思います)．</p>
<p><img src="/images/20190501-3.png" alt="図3: noneネットワーク" title="図3: noneネットワーク" width="500"></p>
<p>noneネットワークを使用したコンテナのネットワークを確認します．<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> container_name ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/tunnel6 :: brd ::</span><br></pre></td></tr></table></figure></p>
<p>ループバックアドレスのみ表示され，eth0がコンテナにアタッチされていないことが分かります．</p>
<hr>
<h1 id="3-おわりに"><a href="#3-おわりに" class="headerlink" title="3. おわりに"></a>3. おわりに</h1><p>上記の3つのネットワークでは，特に理由がない限りbridgeを利用しておけば良さそうです．<br>また，これ以外にもoverlay networks等がありますが，そこまで勉強が及んでいないため次回以降に記載できればと思っております．</p>
<p>上記以外に私が気になっているポイントとして，NICをプロミスキャスモードで利用するケースの有無です．<br>VMwareで仮想化したサーバの運用が長かったため，VMware的な考えになりがちなのですが，<br>Hypervisor上で仮想マシンを動作させる際は，物理NICをプロミスキャスモードにし，仮想スイッチで各仮想マシンにパケットを振り分けることが一般的です．<br>dockerを利用した際は，そのような利用方法はしないのでしょうか？私 気になります！<br>それでは！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/05/01/Dockerネットワークについて/" data-id="ck4wmoyft0007mbuy7z4fnyz3" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NW/">NW</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Docker-for-Windowsと認証プロキシ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/20/Docker-for-Windowsと認証プロキシ/" class="article-date">
  <time datetime="2019-04-20T01:30:00.000Z" itemprop="datePublished">2019-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/20/Docker-for-Windowsと認証プロキシ/">Docker for Windowsと認証プロキシ</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>1時間ぐらいhttpステータスコード407と戦ったので，備忘録として残しておきます．</p>
<p>認証プロキシ経由でイメージをpush/pullしたい場合，<br>proxiesに以下の設定を入れれば良いです．</p>
<p><img src="/images/20190420-1.png" alt="図1: 認証プロキシ設定" title="図1: 認証プロキシ設定" width="700"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/04/20/Docker-for-Windowsと認証プロキシ/" data-id="ck4wmoyfs0005mbuym15zdwo6" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker-for-Windows/">Docker for Windows</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小ネタ/">小ネタ</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AWSソリューションアーキテクト・アソシエイト試験勉強方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/18/AWSソリューションアーキテクト・アソシエイト試験勉強方法/" class="article-date">
  <time datetime="2019-04-18T14:00:00.000Z" itemprop="datePublished">2019-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/18/AWSソリューションアーキテクト・アソシエイト試験勉強方法/">AWSソリューションアーキテクト・アソシエイト試験勉強方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>職場でAWSソリューションアーキテクト試験の勉強方法を質問されたので，簡潔にまとめてみました．<br>せっかくまとめたので，こちらにもアップしようと思います．<br>ご参考までに．</p>
<hr>
<h1 id="2-AWSの認定試験"><a href="#2-AWSの認定試験" class="headerlink" title="2. AWSの認定試験"></a>2. AWSの認定試験</h1><p>AWSの認定試験は，下記のような体系です．<br><img src="/images/20190418-1.png" alt="図1: AWS認定試験体系" title="図1: AWS認定試験体系()" width="500"><br>※<a href="https://aws.amazon.com/jp/certification/" target="_blank" rel="noopener">図の出典はAWS公式ホームページ</a></p>
<p>レベルは，FoundationalからProfessionalまであり，それとは別カテゴリーとしてSpecialtyがあります．<br>SpecialtyはAWSのサービスの中で，より専門性の高いモノ(例えばSecurityなど)を出題範囲としています．</p>
<p>この中で，今回対象とするのは赤枠で囲った試験(ソリューションアーキテクト・アソシエイト)です．<br>私の周りでは，AWS認定初級試験として認識されている印象ですが，<br>出題範囲は広く，サーバやNWの知識からDBやCDNまで問われるため，きちんと勉強しなければ合格することができません．<br>主にサービスの仕様を答える問題が多いのが特徴で，AWSの考え方や仕様をきちんと理解する必要があります．</p>
<p>，，，ですが，きちんと勉強すればそこまで難しい試験ではありませんのでご安心を！</p>
<hr>
<h1 id="3-アソシエイト認定に向けての勉強方法"><a href="#3-アソシエイト認定に向けての勉強方法" class="headerlink" title="3. アソシエイト認定に向けての勉強方法"></a>3. アソシエイト認定に向けての勉強方法</h1><h2 id="3-1-学習すべきサービス"><a href="#3-1-学習すべきサービス" class="headerlink" title="3.1 学習すべきサービス"></a>3.1 学習すべきサービス</h2><p>ソリューションアーキテクトの試験は出題範囲が広いですが，全てのサービスを理解する必要はありません．<br>なので，必要なサービスに絞って勉強していくことが大切です．<br>では何を勉強すべきか．．．私は以下のように考えています．<br><img src="/images/20190418-2.png" alt="図2: 学習すべきサービス一覧" title="図2: 学習すべきサービス一覧" width="700"><br>優先度(高)のサービスは頻出です．まず出題されると考えてもらって構いません．<br>優先度(中)のサービスは出題頻度高めで，失点は合否に関わると思います．<br>優先度(低)のサービスは，学習優先度は落ちますが，勉強しておいて損はありません．</p>
<h2 id="3-2-学習方法"><a href="#3-2-学習方法" class="headerlink" title="3.2 学習方法"></a>3.2 学習方法</h2><p>学習効率が高い方法は，下記の2つです．</p>
<ul>
<li><a href="https://aws.amazon.com/jp/aws-jp-introduction/aws-jp-webinar-service-cut/" target="_blank" rel="noopener">BlackBelt</a>を読んで，AWSマネジメントコンソールで遊ぶ</li>
<li><a href="https://aws.amazon.com/jp/certification/certification-prep/" target="_blank" rel="noopener">AWS公式の認定模試</a>を受験する</li>
</ul>
<p>「習うより慣れろ」です！BlackBeltを軽く確認したら，AWSでいっぱい遊んでください．<br>例えば，「システム構成図通りにAWSに環境を構築する」なんて良いかもしれません．<br>システム構成図例は，<a href="https://www.ketancho.net/entry/2018/05/07/080000" target="_blank" rel="noopener">このブログ</a>を参考にすると良いでしょう．AWSでよく利用される構成が解説されています．</p>
<p>また，ある程度AWSに慣れてきたら模試を受験しましょう．<br>30分で25問出題されるので，出題傾向をつかむことができます(お金は多少かかってしまいますが，，，)．</p>
<hr>
<h1 id="4-おわりに"><a href="#4-おわりに" class="headerlink" title="4. おわりに"></a>4. おわりに</h1><p>AWSの理解を深めるのには，実際AWSを実際に利用してみるのが一番です．<br>勉強で得た知識を，資格というカタチで見える化してみてはどうでしょうか？<br>それでは！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/04/18/AWSソリューションアーキテクト・アソシエイト試験勉強方法/" data-id="ck4wmoyfq0003mbuyly1ffknr" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AWS/">AWS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/認定試験/">認定試験</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-幅優先探索について" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/17/幅優先探索について/" class="article-date">
  <time datetime="2019-04-17T10:30:00.000Z" itemprop="datePublished">2019-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/17/幅優先探索について/">幅優先探索について</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>約1ヶ月前に，<a href="http://localhost:4000/2019/03/10/%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/" target="_blank" rel="noopener">深さ優先探索の記事</a>を書きました．<br>深さ優先全探索で網羅的に事象を探索できるため，幅優先探索の勉強は後回しになっていたのですが，<br>先日の<a href="https://atcoder.jp/contests/s8pc-6" target="_blank" rel="noopener">square869120Contest #6</a>で幅優先探索が必要になったため，急遽勉強しました(深さ優先探索だとTLEでした…)，<br>それではいきましょう！</p>
<hr>
<h1 id="2-幅優先探索"><a href="#2-幅優先探索" class="headerlink" title="2. 幅優先探索"></a>2. 幅優先探索</h1><p>幅優先探索とは，ツリー構造の事象をルートから近い順に探索していきます．<br>図に描くと以下のような感じになります．<br><img src="/images/20190417-1.png" alt="図1: 幅優先探索 探索順" title="図1: 幅優先探索 探索順" width="500"><br>図の丸は事象を表し，数字は探索順を表します．<br>探索はルートより開始され，ルートから近い順に探索が実施されていることがわかるかと思います．<br>幅優先探索は，迷路の最短経路探索で利用されるケースが多いようです．</p>
<hr>
<h1 id="3-深さ優先探索と幅優先探索の使い分け"><a href="#3-深さ優先探索と幅優先探索の使い分け" class="headerlink" title="3. 深さ優先探索と幅優先探索の使い分け"></a>3. 深さ優先探索と幅優先探索の使い分け</h1><p>深さ優先探索でも幅優先探索でも，事象の全探索は可能です，<br>では，どのような基準で深さ優先探索と幅優先探索の使い分けるのでしょうか．<br>私なりにまとめてみました．</p>
<h3 id="幅優先探索利用ケース"><a href="#幅優先探索利用ケース" class="headerlink" title="幅優先探索利用ケース"></a>幅優先探索利用ケース</h3><ul>
<li>ルートの近くに解が存在する可能性がある場合</li>
<li>探索範囲が広く，深さ優先探索ではスタックが大量に利用されてしまう場合</li>
</ul>
<h3 id="深さ優先探索利用ケース"><a href="#深さ優先探索利用ケース" class="headerlink" title="深さ優先探索利用ケース"></a>深さ優先探索利用ケース</h3><ul>
<li>全通りを列挙し、結果をまとめる必要がある場合
　　</li>
</ul>
<hr>
<h1 id="4-幅優先探索の実装"><a href="#4-幅優先探索の実装" class="headerlink" title="4. 幅優先探索の実装"></a>4. 幅優先探索の実装</h1><p>幅優先探索の擬似コードを記載します．<br>本擬似コードは，迷路の最適経路探索をイメージしながら記載しました．<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bfs</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> q = <span class="comment">/* 初期値 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 探索済みフラグ */</span></span><br><span class="line">    <span class="keyword">var</span> flag[][] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.length)&#123;</span><br><span class="line">        <span class="comment">/* 探索範囲取り出し */</span></span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* ゴール？ */</span></span><br><span class="line">        <span class="keyword">if</span>(q == <span class="string">"ゴール"</span>) &#123; <span class="keyword">return</span>( <span class="comment">/* ゴール */</span>); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 探索済みならcontinue */</span></span><br><span class="line">        <span class="keyword">if</span>( flag[][] == <span class="number">1</span> )&#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">      </span><br><span class="line">      　<span class="comment">/* 探索済みフラグセット */</span> </span><br><span class="line">        flag[][] = <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(<span class="comment">/* 次の探索範囲がある */</span>) q.push( <span class="comment">/* 次の探索範囲 */</span> );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>( <span class="comment">/* ゴールせず */</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>幅優先探索はループで記載されることが多いようです．<br>探索候補を格納する変数qから探索候補を1つずつ取り出し，それがゴールであるか確認します(L12)．<br>ゴールでなければ探索済みフラグを立て，次の探索範囲を変数qへ追加します(L20)．<br>全ての探索が完了した場合(qが空になった場合)，関数bfs内の処理が終了します(L23)．</p>
<hr>
<h1 id="5-おわりに"><a href="#5-おわりに" class="headerlink" title="5. おわりに"></a>5. おわりに</h1><p>幅優先探索でした．ご理解いただけたら幸いです．<br>アルゴリズム関係で次に予定している題材は，動的計画法です．<br>以前にもさらっとブログに書きましたが，もう少し深いところまで記載できたらと考えています(動的計画法 奥深すぎです汗)<br>それでは！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/04/17/幅優先探索について/" data-id="ck4wmoyg4000nmbuy5whfd2lz" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/アルゴリズム/">アルゴリズム</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AWSアカウントとアベイラビリティーゾーン名" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/AWSアカウントとアベイラビリティーゾーン名/" class="article-date">
  <time datetime="2019-04-16T11:15:00.000Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/AWSアカウントとアベイラビリティーゾーン名/">AWSアカウントとアベイラビリティーゾーン名</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>AWSに関して小ネタを仕入れたので紹介します．<br>それではいきましょう！</p>
<hr>
<h1 id="2-リージョンとアベイラビリティーゾーン"><a href="#2-リージョンとアベイラビリティーゾーン" class="headerlink" title="2. リージョンとアベイラビリティーゾーン"></a>2. リージョンとアベイラビリティーゾーン</h1><p>AWSでは，データセンター群をリージョンという単位で分割しています．<br>リージョンとは直訳した通り”地域”を指し，AWSがデータセンターを展開している地域を指します．<br>リージョンはデータセンター群を表すもっとも大きい単位であり，日本であれば東京リージョンと大阪ローカルリージョンの2つがあります．</p>
<p>さらに，各リージョン内に所属する複数のデータセンタを細分化したグループをアベイラビリティーゾーン(AZ)と呼びます．<br>AZ同士は高速回線で接続されており，AZ間では低遅延で通信することが可能です，<br>図で表すと，下記のような関係です．</p>
<p><img src="/images/20190416-1.png" alt="図1: リージョンとアベイラビリティーゾーン" title="図1: リージョンとアベイラビリティーゾーン" width="500"></p>
<p>一番外側の枠がリージョンを示し，丸がAZを示します．<br>それぞれのAZには名前がついており，東京リージョンの場合だと<strong>ap-northeast-1[a|c|d]</strong>と呼ばれます．</p>
<hr>
<h1 id="3-AWSアカウントとアベイラビリティーゾーン名の関係性"><a href="#3-AWSアカウントとアベイラビリティーゾーン名の関係性" class="headerlink" title="3. AWSアカウントとアベイラビリティーゾーン名の関係性"></a>3. AWSアカウントとアベイラビリティーゾーン名の関係性</h1><p>さて，ここからが本題です．<br>AWSの公式ベージにAZに関して興味深い説明がありました．</p>
<p><strong>アベイラビリティーゾーンは、リージョンコードとそれに続く文字識別子によって表されます(us-east-1a など)。</strong><br><strong>リソースがリージョンの複数のアベイラビリティーゾーンに分散されるようにするため、アベイラビリティーゾーンは各AWSアカウントの名前に個別にマップされます。</strong><br><strong>たとえば、ご使用のAWSアカウントのアベイラビリティーゾーンus-east-1aは別のAWSアカウントのアベイラビリティーゾーンus-east-1aと同じ場所にはない可能性があります。</strong></p>
<p>何を言ってるか分かりますか？<br>「Aさんのus-east-1aと Bさんのus-east-1aは異なる可能性があるよ．なぜなら，各AZの使用リソースが偏らないようにするためだ．」と言っています．<br>ユーザは無意識のうちに若い番号のAZから利用する可能性が高く，AWSはAZごとのリソースの偏りを恐れたのでしょうね．</p>
<p>では，AさんとBさんが同一のAZにシステムを作る方法はないのでしょうか．<br>AWSの公式には，次のようにあります．</p>
<p><strong>アカウント間でアベイラビリティーゾーンを調整するには、アベイラビリティーゾーンの一意で一貫性のある識別子であるAZ IDを使用する必要があります．</strong></p>
<p>つまり，異なるアカウントで同一のAZを利用したい場合，AZ IDを合わせることで実現できそうです．</p>
<hr>
<h1 id="4-おわりに"><a href="#4-おわりに" class="headerlink" title="4. おわりに"></a>4. おわりに</h1><p>今日は，AWS小ネタでした．<br>次回のAWSネタとして，CloudFormation か DNS周り か WorkSpacesの説明を予定しています．<br>早くアップロードできるように頑張りますb<br>ではノシ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/04/16/AWSアカウントとアベイラビリティーゾーン名/" data-id="ck4wmoyfn0001mbuy0dpnx6t8" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AWS/">AWS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小ネタ/">小ネタ</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">次へ &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">タグ</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWS/">AWS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CloudFormation/">CloudFormation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker-for-Windows/">Docker for Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NW/">NW</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/アルゴリズム/">アルゴリズム</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/トラブル/">トラブル</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ライフハック/">ライフハック</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小ネタ/">小ネタ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/競技プログラミング/">競技プログラミング</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/認定試験/">認定試験</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">タグクラウド</h3>
    <div class="widget tagcloud">
      <a href="/tags/AWS/" style="font-size: 17.5px;">AWS</a> <a href="/tags/CloudFormation/" style="font-size: 10px;">CloudFormation</a> <a href="/tags/DP/" style="font-size: 10px;">DP</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Docker-for-Windows/" style="font-size: 10px;">Docker for Windows</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Javascript/" style="font-size: 10px;">Javascript</a> <a href="/tags/NW/" style="font-size: 10px;">NW</a> <a href="/tags/アルゴリズム/" style="font-size: 20px;">アルゴリズム</a> <a href="/tags/トラブル/" style="font-size: 12.5px;">トラブル</a> <a href="/tags/ライフハック/" style="font-size: 15px;">ライフハック</a> <a href="/tags/小ネタ/" style="font-size: 12.5px;">小ネタ</a> <a href="/tags/競技プログラミング/" style="font-size: 17.5px;">競技プログラミング</a> <a href="/tags/認定試験/" style="font-size: 10px;">認定試験</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">アーカイブ</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最近の投稿</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/02/AWSで資産管理してみる2/">AWSで資産管理してみる#2</a>
          </li>
        
          <li>
            <a href="/2019/10/26/婚活サイトから更新情報取得するライフハック/">婚活サイトから更新情報取得するライフハック</a>
          </li>
        
          <li>
            <a href="/2019/10/11/AWSで資産管理してみる1/">AWSで資産管理してみる#1</a>
          </li>
        
          <li>
            <a href="/2019/06/22/桁DP実装したった/">桁DP実装したった</a>
          </li>
        
          <li>
            <a href="/2019/05/07/最短経路問題を解く/">最短経路問題を解く</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Kosuke<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>