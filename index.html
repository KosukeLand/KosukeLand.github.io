<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>某SIerの技術備忘録</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="某SIerの技術備忘録">
<meta property="og:url" content="https://kosukeland.github.io/index.html">
<meta property="og:site_name" content="某SIerの技術備忘録">
<meta property="og:locale" content="ja">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="某SIerの技術備忘録">
  
    <link rel="alternate" href="/atom.xml" title="某SIerの技術備忘録" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">某SIerの技術備忘録</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSSフィード"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="検索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kosukeland.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-桁DP実装したった" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/22/桁DP実装したった/" class="article-date">
  <time datetime="2019-06-22T14:00:00.000Z" itemprop="datePublished">2019-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/22/桁DP実装したった/">桁DP実装したった</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>今日は久しぶりにDPネタを扱ってみようと思います．<br>DPネタで有名なのはナップサック問題ですが，経路探索もDPですし，LCSと呼ばれる文字列探索DPもあります．<br>DPは奥が深いのです！！<br>そんな奥が深いDPのなかで，今日は桁DPを扱います．<br>それでは行ってみましょー！！</p>
<p>最近，筆者のメイン言語がJavaScriptからGolangに変わりました．<br>今後，コードの書き方がGolangライクになるかと思いますが，ご了承下さいm(_ _)m</p>
<hr>
<h1 id="2-桁DPの考え方-および-実装"><a href="#2-桁DPの考え方-および-実装" class="headerlink" title="2. 桁DPの考え方 および 実装"></a>2. 桁DPの考え方 および 実装</h1><p>桁DPとは，複数の数字列に対して特定の数字の出現回数をカウントする場合に利用するアルゴリズムです．<br>以下の具体例を見ながら，勉強していきましょう．</p>
<p>1から順に9876まで書き出した際に，「1」を書く回数を調査<br>(例えば，1から12を記載する場合，1が出現するのは1,10,11,12であり，1の記載回数は5)</p>
<p>まずは，ナイーブなアルゴリズムから記載します．<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数値Nの桁ごとの数字のカウント</span></span><br><span class="line">N = <span class="number">9876</span>; x = <span class="number">1</span>;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">    <span class="comment">// 桁ごとに数字を分割</span></span><br><span class="line">    z = i.split()</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; z.length ; j++)&#123;</span><br><span class="line">        <span class="comment">// i桁目の数字がxなら，ans++</span></span><br><span class="line">        <span class="keyword">if</span>(z[j] == x)&#123; ans++ &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>この場合，1から9876までの数字列の各桁を参照し，それが「1」と一致するか判定することで「1」の記載回数を探索しています．<br>したがって，計算量はO(N^2)となります．</p>
<p>ただしこのプログラムは，<br>「桁ごとの数字が異なっていても1の出現回数が同一であれば，同一箇所を複数回計算する必要はない」<br>という理由で無駄が多いと言えます．<br>少し分かりづらいですよね．詳細を説明します．<br>例えば，12010と12058のように一致している桁がある場合(この場合は，上位3桁が一致している)，<br>一致箇所の結果を記憶しておくことで，複数回探索する必要はないことはすぐ分かると思います．<br>つまり，「120では1は1回しか記述しない」と記憶しておくことで，12001は120で1は1回，10で1が1回　合わせて2回とできそうです．</p>
<p>しかし，さらに計算量を削減できることに気付きます．<br>なぜなら，今回重要な情報は1の出現回数であり，各桁の数字が一致しているかどうかは1の出現回数に影響がないからです．<br>例えば，1321と1541のような上位3桁は異なっていたとしても，1の出現回数は同じならば，それぞれを個別に考慮する必要はありません．<br>同一の状況として記憶すれば良いのです．</p>
<p>では，上記のアルゴリズムでプログラムを書いていきましょう．</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数値Nの桁ごとの数字のカウント</span></span><br><span class="line">N = <span class="number">9876</span>; x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">memo = [][][]</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// k: 現在探索している桁数(上位から数えてk桁目)</span></span><br><span class="line"><span class="comment">// tight: 上位から数えてk桁目の取りうる値の範囲を示すフラグ trueの場合，k桁目の取りうる値の範囲が制限される</span></span><br><span class="line"><span class="comment">// sum:  1が出現した回数をカウント</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">k, tight, sum</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 入力が一致していたら，メモ化(図1:条件3)</span></span><br><span class="line">    <span class="keyword">if</span>(memo[k][tight][sum]) &#123; <span class="keyword">return</span> (memo[k][tight][sum]) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// k桁目がN.lengthと一致したら終了</span></span><br><span class="line">    <span class="keyword">if</span>(k === N.length)&#123; <span class="keyword">return</span> (sum); &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment">// k桁目が取りうる値の範囲(図1:条件2)</span></span><br><span class="line">        r = (tight ? N[k] : <span class="number">9</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="comment">//k桁目がxならば(図1:条件1)</span></span><br><span class="line">            <span class="keyword">if</span>(i == x)&#123; res += dfs(k + <span class="number">1</span>,(tight &amp;&amp; i == r), sum + <span class="number">1</span>); &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; res += dfs(k + <span class="number">1</span>,(tight &amp;&amp; i == r), sum); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 結果を記憶し再利用</span></span><br><span class="line">        memo[k][tight][sum] = res;</span><br><span class="line">        <span class="keyword">return</span>(memo[k][tight][sum])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再帰関数で記載する方が好みであるので，このように記載しました(まぁ，桁DPの解説はほぼメモ化使ってる気がするが．．)．<br>本プログラムは図1の条件1，条件2，条件3をもとに計算しています．<br>kが検索対象である1と同一であれば合計値を加算し，加えて条件2，条件3を適用することで，検索対象を絞っています．<br><img src="/images/20190622-1.png" alt="図1: 桁DPの考え方" title="図1: 桁DPの考え方" width="700"></p>
<hr>
<h1 id="3-おわりに"><a href="#3-おわりに" class="headerlink" title="3. おわりに"></a>3. おわりに</h1><p>今日は，桁DPについてふれていきました．<br>AtCoderでも桁DP問題があるので，解いて理解を深めていきましょう．<br>それではーノシ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/06/22/桁DP実装したった/" data-id="cjx7ojxl8000u8vuyswh2gfhj" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DP/">DP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/アルゴリズム/">アルゴリズム</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-最短経路問題を解く" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/07/最短経路問題を解く/" class="article-date">
  <time datetime="2019-05-07T13:00:00.000Z" itemprop="datePublished">2019-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/07/最短経路問題を解く/">最短経路問題を解く</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>競技プログラミングにおいて，最短経路探索を問われるケースは多々あります．<br>以前より，興味があった分野であるため少し勉強してみました．<br>今日は，代表的なアルゴリズムである，ワーシャルフロイド法とダイクストラ法を解説していきます．<br>それではいきましょう！</p>
<hr>
<h1 id="2-ワーシャルフロイド法"><a href="#2-ワーシャルフロイド法" class="headerlink" title="2. ワーシャルフロイド法"></a>2. ワーシャルフロイド法</h1><p>ワーシャルフロイド法の方がダイクストラ法に比べて平易であり理解が進むと思うため，こちらを先に記載しています．<br>ワーシャルフロイド法では，ノードkを経由してノードiからノードjへ移動する最小コストを更新していきます．<br>計算量はO(V^3)と少し重めですが，全てのノード間の最短経路を計算できるため有用です．<br>図を利用して説明しましょう．</p>
<p><img src="/images/20190507-1.png" alt="図1: ワーシャルフロイド法解説" title="図1: ワーシャルフロイド法解説" width="500"></p>
<p>図中の丸はノードを 線はノード間の接続を表し，線上に記載された値はノード移動の際に発生するコストを表します．<br>ワーシャルフロイド法では全ノード間の最短経路を探索するため，本来は全てのノードの探索を説明する必要があるのですが，<br>ここでは，ノードAからノードEへの最小コストにのみに着目し説明したいと思います．<br>まず，図よりノードAはノードBと接続しているため，ノードBを経由すればノードEへ到達できそうです．<br>その際のコストは15(5+10)となります．現在の最小コストとなります(青)．<br>次にノードAからノードBを経由してノードDへ到達した場合のコスト9(5+4)を記憶します(赤)．<br>最後にノードAからノードDを経由してノードE到達した場合，コストは13(9+4)となるため，最小コストが更新されます(赤)．</p>
<p>このようにして最短経路を更新し続け，最終的に出力される経路が最短となります．<br>では，実装してみましょう．<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配列dをコストで初期化</span></span><br><span class="line"><span class="comment">// d[start][goal] = cost;</span></span><br><span class="line"></span><br><span class="line">V = ノード数</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中継ノード</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span> ; k = V ; k++)&#123;</span><br><span class="line">    <span class="comment">// スタートノード    </span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i = V ; i++)&#123;</span><br><span class="line">        <span class="comment">// ゴールノード</span></span><br><span class="line">        <span class="keyword">for</span>(j) = <span class="number">0</span> ; j = V ; j++)&#123;</span><br><span class="line">            d[i][j] = Min(d[i][j], d[i][k] + d[k][j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上記の通り，アルゴリズムが非常に平易であるため，計算量的に厳しくなければワーシャルフロイドを利用することが良いでしょう．<br>AtCoderの場合，ノード数が10^2以内であれば間に合いそうです．<br>それ以上になると，計算量を落としたアルゴリズムを利用する必要があります．</p>
<hr>
<h1 id="3-ダイクストラ法"><a href="#3-ダイクストラ法" class="headerlink" title="3. ダイクストラ法"></a>3. ダイクストラ法</h1><p>インプットが少なければ，ワーシャルフロイド法で良いのですが，<br>インプットが大きい場合(例えば，ノードが10^3を超える場合)はダイクストラ法を利用することになるでしょう．<br>ダイクストラ法では，特定のスタートノードからの最短経路が確定していないノードに着目し，当該ノードの最短経路を確定させ続けることでスタートノードからゴールノードへの最短経路を確定させます．</p>
<p><img src="/images/20190507-2.png" alt="図2: ダイクストラ法解説-1" title="図2: ダイクストラ法解説-1" width="500"></p>
<p>ワーシャルフロイド法と同様にノードAからノードEへの最短経路を探索します．<br>まず，ノードAより移動可能なノードBのみなのでノードBへの最短経路は5と確定します．</p>
<p><img src="/images/20190507-3.png" alt="図3: ダイクストラ法解説-2" title="図3: ダイクストラ法解説-2" width="500"></p>
<p>次にノードBより移動可能なノードは，ノードC，ノードD，ノードEなので それぞれのノードへの移動コストを計算します．<br>計算すると12，9，15とわかります．<br>この中でノードDへ移動コストはこの中で最小の9であるため，ノードAからノードDへの移動の最小コストであるとわかります．</p>
<p><img src="/images/20190507-4.png" alt="図4: ダイクストラ法解説-3" title="図4: ダイクストラ法解説-3" width="500"></p>
<p>最後に，ノードDから移動可能なノードEであり，その距離は4であることが図からわかります．<br>そのため，ノードAからノードEへの最小コストは13であるとわかります．</p>
<p>さて，ダイクストラ法も実装してみましょう．</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配列costをコストで初期化</span></span><br><span class="line"><span class="comment">// (インプットとしてコストが与えられない場合，そのコストはInfinity)</span></span><br><span class="line"><span class="comment">// cost[start][goal] = cost;</span></span><br><span class="line"></span><br><span class="line">V = ノード数</span><br><span class="line">used[] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// スタート地点まで到達するためのコストは0</span></span><br><span class="line">d[start] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    v = <span class="number">-1</span> ;</span><br><span class="line">    <span class="comment">// 最短経路が確定していないノードの中で，現在スタート地点からの距離が最短のノードを探索</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[i] &amp;&amp; (v == <span class="number">-1</span> || d[i] &lt; d[v]))&#123; </span><br><span class="line">            v = i;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用フラグ立てる</span></span><br><span class="line">    used[i] = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ノードを全て利用している場合，ループ終了</span></span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">-1</span>)&#123; <span class="keyword">break</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 現在のノードvまでのコスト と ノードiまでのコストとノードiからノードvへのコストの合計 の小さい方を選択</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line">        d[v] = Min(d[v], d[i] + cost[i][v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分集合の解を計算することで目的の値を取得することから，本アルゴリズムは計算動的計画法と言えると思います．<br>またダイクストラ法では，最短経路が確定した際に経路を記憶することで，スタートノードからゴールノードまでの経路情報を生成することも可能です．</p>
<hr>
<h1 id="4-おわりに"><a href="#4-おわりに" class="headerlink" title="4. おわりに"></a>4. おわりに</h1><p>今日は経路探索アルゴリズムをみていきました．<br>実は，有名なアルゴリズムとしてベルマンフォード法もあるのですが，<br>負の閉路が存在するグラフ以外適用されないアルゴリズムであり，基本的に上記の2つの学習優先度の方が高いと判断しました．<br>良ければ学んでみてください．<br>それでは！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/05/07/最短経路問題を解く/" data-id="cjx7ojxl5000p8vuyx0tnlixb" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/アルゴリズム/">アルゴリズム</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/競技プログラミング/">競技プログラミング</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Dockerネットワークについて" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/01/Dockerネットワークについて/" class="article-date">
  <time datetime="2019-05-01T13:00:00.000Z" itemprop="datePublished">2019-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/01/Dockerネットワークについて/">Dockerネットワークについて</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>簡単な検証をすることが最近多いのですが，その際にDockerを触ることが多くなりました．<br>多くのプロダクトがDockerHubより提供されているため，簡単な検証環境を構築する際にDockerは大変便利です．<br>特に私の場合ローカルのPCスペックがそこまで良くないので，複数台のマシン(or 仮想マシン)を使った検証をすることができず<br>必然的にDockerを利用して検証環境を作ることになります．<br>これだけ世間で流行る理由がよくわかります．もう検証環境を構築するために仮想マシン立てることはできないでしょう．<br>めんどくさいですしw</p>
<p>さて，今日はDockerの中でもネットワークに関して，少し触れていきたいと思います．</p>
<hr>
<h1 id="2-Dockerネットワーク概要"><a href="#2-Dockerネットワーク概要" class="headerlink" title="2. Dockerネットワーク概要"></a>2. Dockerネットワーク概要</h1><p>Dockerコンテナを起動させると，コンテナに対しネットワークが割り当てられます．<br>特に設定していない場合は”bridge”が利用され，ホストマシンをブリッジして外部の環境と通信をすることになります．</p>
<p>しかし，Dockerネットワークにはbridge以外にも以下のネットワークがデフォルトで用意されています．</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">xxxxxxxxxxxx        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">yyyyyyyyyyyy        host                host                <span class="built_in">local</span></span><br><span class="line">zzzzzzzzzzzz        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<h2 id="2-1-bridgeネットワーク"><a href="#2-1-bridgeネットワーク" class="headerlink" title="2.1 bridgeネットワーク"></a>2.1 bridgeネットワーク</h2><p>docker0と呼ばれる仮想ブリッジ経由で通信する形式です．<br>各コンテナはveth(カーネルが提供するか仮想インターフェース)を介して仮想ブリッジに接続されます．<br>図で書くと以下のようになります．</p>
<p><img src="/images/20190501-1.png" alt="図1: bridgeネットワーク" title="図1: bridgeネットワーク" width="500"></p>
<p>コンテナはeth0というNICを認識し(実体はveth)，当該NICを利用してコンテナ同士 又は外部機器と通信します．<br>コンテナとホストマシンのネットワークは分離されているため，それぞれ異なるアドレスレンジを利用します．<br>なので，外部機器と通信する際はdocker0をデフォルトゲートウェイに利用し，そこでホストマシンのアドレスにNATされます．</p>
<p>ここで注意すべき点として，<br>コンテナはDockerが管理するアドレス空間から利用されていないIPアドレスが自動的に割り当てられるため，コンテナのIPは不定となります．<br>DHCPを想像していただければ分かりやすいかと思います．<br>コンテナに割り当てられるアドレスレンジの確認は，以下のコマンドで行います．</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect bridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"5482b53471090013ec6ec2605214545e595d713dede280e815dcc9efb0968458"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2019-05-01T12:40:10.365713105Z"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: null,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"172.17.0.0/16"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.17.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"ConfigFrom"</span>: &#123;</span><br><span class="line">            <span class="string">"Network"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ConfigOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"f1761e429f3c3b797ea6db3e9f7ceae43190a43b5186e9805e32e78b50e6f616"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"fuga"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"04815728bd8de73d69fe09b22f0f6b4feb61a5e609543b93731b336d0b8e54a9"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"172.17.0.2/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      :</span><br><span class="line">   〜省略〜</span><br><span class="line">      :</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>コマンドの結果を確認すると，コンテナには172.17.0.0/16のネットワークが割り当てられ<br>そのデフォルトゲートウェイは172.17.0.1であることがわかります．<br>また，コンテナには，172.17.0.2のアドレスが割り当てられていることも合わせて確認することができます．</p>
<h2 id="2-2-hostネットワーク"><a href="#2-2-hostネットワーク" class="headerlink" title="2.2 hostネットワーク"></a>2.2 hostネットワーク</h2><p>使ったことないので，軽めの説明です．<br>ホストマシンと同一のアドレスをコンテナで利用する際に本ネットワークを選択します．<br>図で書くと以下のような構成になります．</p>
<p><img src="/images/20190501-2.png" alt="図2: hostネットワーク" title="図2: hostネットワーク" width="500"></p>
<p>hostネットワークに所属する全てのコンテナがホストマシンと同一のアドレスとなるため，<br>通信する際はポートを指定することになります(なるはず)．<br>そのため，利用用途は限られるのではないかと考えています．</p>
<p>※ hostネットワークは，Docker Desktop for Mac 及び Docker Desktop for Windowsで未サポートです．<br><a href="https://docs.docker.com/network/host/" target="_blank" rel="noopener">https://docs.docker.com/network/host/</a></p>
<h2 id="2-2-noneネットワーク"><a href="#2-2-noneネットワーク" class="headerlink" title="2.2 noneネットワーク"></a>2.2 noneネットワーク</h2><p>このネットワークも使ったことないので，軽めの説明です．<br>公式ドキュメントに，「全てのネットワークがdisableになる」と記載があるため，<br>任意のコンテナが他のコンテナ 及び 外部と通信しない場合，本ネットワークを選択します．<br>図で書くと以下のような構成になります(と思います)．</p>
<p><img src="/images/20190501-3.png" alt="図3: noneネットワーク" title="図3: noneネットワーク" width="500"></p>
<p>noneネットワークを使用したコンテナのネットワークを確認します．<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> container_name ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/tunnel6 :: brd ::</span><br></pre></td></tr></table></figure></p>
<p>ループバックアドレスのみ表示され，eth0がコンテナにアタッチされていないことが分かります．</p>
<hr>
<h1 id="3-おわりに"><a href="#3-おわりに" class="headerlink" title="3. おわりに"></a>3. おわりに</h1><p>上記の3つのネットワークでは，特に理由がない限りbridgeを利用しておけば良さそうです．<br>また，これ以外にもoverlay networks等がありますが，そこまで勉強が及んでいないため次回以降に記載できればと思っております．</p>
<p>上記以外に私が気になっているポイントとして，NICをプロミスキャスモードで利用するケースの有無です．<br>VMwareで仮想化したサーバの運用が長かったため，VMware的な考えになりがちなのですが，<br>Hypervisor上で仮想マシンを動作させる際は，物理NICをプロミスキャスモードにし，仮想スイッチで各仮想マシンにパケットを振り分けることが一般的です．<br>dockerを利用した際は，そのような利用方法はしないのでしょうか？私 気になります！<br>それでは！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/05/01/Dockerネットワークについて/" data-id="cjx7ojxkt00078vuytihr18fd" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NW/">NW</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Docker-for-Windowsと認証プロキシ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/20/Docker-for-Windowsと認証プロキシ/" class="article-date">
  <time datetime="2019-04-20T01:30:00.000Z" itemprop="datePublished">2019-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/20/Docker-for-Windowsと認証プロキシ/">Docker for Windowsと認証プロキシ</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>1時間ぐらいhttpステータスコード407と戦ったので，備忘録として残しておきます．</p>
<p>認証プロキシ経由でイメージをpush/pullしたい場合，<br>proxiesに以下の設定を入れれば良いです．</p>
<p><img src="/images/20190420-1.png" alt="図1: 認証プロキシ設定" title="図1: 認証プロキシ設定" width="700"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/04/20/Docker-for-Windowsと認証プロキシ/" data-id="cjx7ojxks00068vuyj05terxg" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker-for-Windows/">Docker for Windows</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小ネタ/">小ネタ</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AWSソリューションアーキテクト・アソシエイト試験勉強方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/18/AWSソリューションアーキテクト・アソシエイト試験勉強方法/" class="article-date">
  <time datetime="2019-04-18T14:00:00.000Z" itemprop="datePublished">2019-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/18/AWSソリューションアーキテクト・アソシエイト試験勉強方法/">AWSソリューションアーキテクト・アソシエイト試験勉強方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>職場でAWSソリューションアーキテクト試験の勉強方法を質問されたので，簡潔にまとめてみました．<br>せっかくまとめたので，こちらにもアップしようと思います．<br>ご参考までに．</p>
<hr>
<h1 id="2-AWSの認定試験"><a href="#2-AWSの認定試験" class="headerlink" title="2. AWSの認定試験"></a>2. AWSの認定試験</h1><p>AWSの認定試験は，下記のような体系です．<br><img src="/images/20190418-1.png" alt="図1: AWS認定試験体系" title="図1: AWS認定試験体系()" width="500"><br>※<a href="https://aws.amazon.com/jp/certification/" target="_blank" rel="noopener">図の出典はAWS公式ホームページ</a></p>
<p>レベルは，FoundationalからProfessionalまであり，それとは別カテゴリーとしてSpecialtyがあります．<br>SpecialtyはAWSのサービスの中で，より専門性の高いモノ(例えばSecurityなど)を出題範囲としています．</p>
<p>この中で，今回対象とするのは赤枠で囲った試験(ソリューションアーキテクト・アソシエイト)です．<br>私の周りでは，AWS認定初級試験として認識されている印象ですが，<br>出題範囲は広く，サーバやNWの知識からDBやCDNまで問われるため，きちんと勉強しなければ合格することができません．<br>主にサービスの仕様を答える問題が多いのが特徴で，AWSの考え方や仕様をきちんと理解する必要があります．</p>
<p>，，，ですが，きちんと勉強すればそこまで難しい試験ではありませんのでご安心を！</p>
<hr>
<h1 id="3-アソシエイト認定に向けての勉強方法"><a href="#3-アソシエイト認定に向けての勉強方法" class="headerlink" title="3. アソシエイト認定に向けての勉強方法"></a>3. アソシエイト認定に向けての勉強方法</h1><h2 id="3-1-学習すべきサービス"><a href="#3-1-学習すべきサービス" class="headerlink" title="3.1 学習すべきサービス"></a>3.1 学習すべきサービス</h2><p>ソリューションアーキテクトの試験は出題範囲が広いですが，全てのサービスを理解する必要はありません．<br>なので，必要なサービスに絞って勉強していくことが大切です．<br>では何を勉強すべきか．．．私は以下のように考えています．<br><img src="/images/20190418-2.png" alt="図2: 学習すべきサービス一覧" title="図2: 学習すべきサービス一覧" width="700"><br>優先度(高)のサービスは頻出です．まず出題されると考えてもらって構いません．<br>優先度(中)のサービスは出題頻度高めで，失点は合否に関わると思います．<br>優先度(低)のサービスは，学習優先度は落ちますが，勉強しておいて損はありません．</p>
<h2 id="3-2-学習方法"><a href="#3-2-学習方法" class="headerlink" title="3.2 学習方法"></a>3.2 学習方法</h2><p>学習効率が高い方法は，下記の2つです．</p>
<ul>
<li><a href="https://aws.amazon.com/jp/aws-jp-introduction/aws-jp-webinar-service-cut/" target="_blank" rel="noopener">BlackBelt</a>を読んで，AWSマネジメントコンソールで遊ぶ</li>
<li><a href="https://aws.amazon.com/jp/certification/certification-prep/" target="_blank" rel="noopener">AWS公式の認定模試</a>を受験する</li>
</ul>
<p>「習うより慣れろ」です！BlackBeltを軽く確認したら，AWSでいっぱい遊んでください．<br>例えば，「システム構成図通りにAWSに環境を構築する」なんて良いかもしれません．<br>システム構成図例は，<a href="https://www.ketancho.net/entry/2018/05/07/080000" target="_blank" rel="noopener">このブログ</a>を参考にすると良いでしょう．AWSでよく利用される構成が解説されています．</p>
<p>また，ある程度AWSに慣れてきたら模試を受験しましょう．<br>30分で25問出題されるので，出題傾向をつかむことができます(お金は多少かかってしまいますが，，，)．</p>
<hr>
<h1 id="4-おわりに"><a href="#4-おわりに" class="headerlink" title="4. おわりに"></a>4. おわりに</h1><p>AWSの理解を深めるのには，実際AWSを実際に利用してみるのが一番です．<br>勉強で得た知識を，資格というカタチで見える化してみてはどうでしょうか？<br>それでは！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/04/18/AWSソリューションアーキテクト・アソシエイト試験勉強方法/" data-id="cjx7ojxko00038vuyu1uea4oc" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AWS/">AWS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/認定試験/">認定試験</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-幅優先探索について" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/17/幅優先探索について/" class="article-date">
  <time datetime="2019-04-17T10:30:00.000Z" itemprop="datePublished">2019-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/17/幅優先探索について/">幅優先探索について</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>約1ヶ月前に，<a href="http://localhost:4000/2019/03/10/%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/" target="_blank" rel="noopener">深さ優先探索の記事</a>を書きました．<br>深さ優先全探索で網羅的に事象を探索できるため，幅優先探索の勉強は後回しになっていたのですが，<br>先日の<a href="https://atcoder.jp/contests/s8pc-6" target="_blank" rel="noopener">square869120Contest #6</a>で幅優先探索が必要になったため，急遽勉強しました(深さ優先探索だとTLEでした…)，<br>それではいきましょう！</p>
<hr>
<h1 id="2-幅優先探索"><a href="#2-幅優先探索" class="headerlink" title="2. 幅優先探索"></a>2. 幅優先探索</h1><p>幅優先探索とは，ツリー構造の事象をルートから近い順に探索していきます．<br>図に描くと以下のような感じになります．<br><img src="/images/20190417-1.png" alt="図1: 幅優先探索 探索順" title="図1: 幅優先探索 探索順" width="500"><br>図の丸は事象を表し，数字は探索順を表します．<br>探索はルートより開始され，ルートから近い順に探索が実施されていることがわかるかと思います．<br>幅優先探索は，迷路の最短経路探索で利用されるケースが多いようです．</p>
<hr>
<h1 id="3-深さ優先探索と幅優先探索の使い分け"><a href="#3-深さ優先探索と幅優先探索の使い分け" class="headerlink" title="3. 深さ優先探索と幅優先探索の使い分け"></a>3. 深さ優先探索と幅優先探索の使い分け</h1><p>深さ優先探索でも幅優先探索でも，事象の全探索は可能です，<br>では，どのような基準で深さ優先探索と幅優先探索の使い分けるのでしょうか．<br>私なりにまとめてみました．</p>
<h3 id="幅優先探索利用ケース"><a href="#幅優先探索利用ケース" class="headerlink" title="幅優先探索利用ケース"></a>幅優先探索利用ケース</h3><ul>
<li>ルートの近くに解が存在する可能性がある場合</li>
<li>探索範囲が広く，深さ優先探索ではスタックが大量に利用されてしまう場合</li>
</ul>
<h3 id="深さ優先探索利用ケース"><a href="#深さ優先探索利用ケース" class="headerlink" title="深さ優先探索利用ケース"></a>深さ優先探索利用ケース</h3><ul>
<li>全通りを列挙し、結果をまとめる必要がある場合
　　</li>
</ul>
<hr>
<h1 id="4-幅優先探索の実装"><a href="#4-幅優先探索の実装" class="headerlink" title="4. 幅優先探索の実装"></a>4. 幅優先探索の実装</h1><p>幅優先探索の擬似コードを記載します．<br>本擬似コードは，迷路の最適経路探索をイメージしながら記載しました．<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bfs</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> q = <span class="comment">/* 初期値 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 探索済みフラグ */</span></span><br><span class="line">    <span class="keyword">var</span> flag[][] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.length)&#123;</span><br><span class="line">        <span class="comment">/* 探索範囲取り出し */</span></span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* ゴール？ */</span></span><br><span class="line">        <span class="keyword">if</span>(q == <span class="string">"ゴール"</span>) &#123; <span class="keyword">return</span>( <span class="comment">/* ゴール */</span>); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 探索済みならcontinue */</span></span><br><span class="line">        <span class="keyword">if</span>( flag[][] == <span class="number">1</span> )&#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">      </span><br><span class="line">      　<span class="comment">/* 探索済みフラグセット */</span> </span><br><span class="line">        flag[][] = <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(<span class="comment">/* 次の探索範囲がある */</span>) q.push( <span class="comment">/* 次の探索範囲 */</span> );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>( <span class="comment">/* ゴールせず */</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>幅優先探索はループで記載されることが多いようです．<br>探索候補を格納する変数qから探索候補を1つずつ取り出し，それがゴールであるか確認します(L12)．<br>ゴールでなければ探索済みフラグを立て，次の探索範囲を変数qへ追加します(L20)．<br>全ての探索が完了した場合(qが空になった場合)，関数bfs内の処理が終了します(L23)．</p>
<hr>
<h1 id="5-おわりに"><a href="#5-おわりに" class="headerlink" title="5. おわりに"></a>5. おわりに</h1><p>幅優先探索でした．ご理解いただけたら幸いです．<br>アルゴリズム関係で次に予定している題材は，動的計画法です．<br>以前にもさらっとブログに書きましたが，もう少し深いところまで記載できたらと考えています(動的計画法 奥深すぎです汗)<br>それでは！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/04/17/幅優先探索について/" data-id="cjx7ojxl4000k8vuy3gqh71lw" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/アルゴリズム/">アルゴリズム</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AWSアカウントとアベイラビリティーゾーン名" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/AWSアカウントとアベイラビリティーゾーン名/" class="article-date">
  <time datetime="2019-04-16T11:15:00.000Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/AWSアカウントとアベイラビリティーゾーン名/">AWSアカウントとアベイラビリティーゾーン名</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>AWSに関して小ネタを仕入れたので紹介します．<br>それではいきましょう！</p>
<hr>
<h1 id="2-リージョンとアベイラビリティーゾーン"><a href="#2-リージョンとアベイラビリティーゾーン" class="headerlink" title="2. リージョンとアベイラビリティーゾーン"></a>2. リージョンとアベイラビリティーゾーン</h1><p>AWSでは，データセンター群をリージョンという単位で分割しています．<br>リージョンとは直訳した通り”地域”を指し，AWSがデータセンターを展開している地域を指します．<br>リージョンはデータセンター群を表すもっとも大きい単位であり，日本であれば東京リージョンと大阪ローカルリージョンの2つがあります．</p>
<p>さらに，各リージョン内に所属する複数のデータセンタを細分化したグループをアベイラビリティーゾーン(AZ)と呼びます．<br>AZ同士は高速回線で接続されており，AZ間では低遅延で通信することが可能です，<br>図で表すと，下記のような関係です．</p>
<p><img src="/images/20190416-1.png" alt="図1: リージョンとアベイラビリティーゾーン" title="図1: リージョンとアベイラビリティーゾーン" width="500"></p>
<p>一番外側の枠がリージョンを示し，丸がAZを示します．<br>それぞれのAZには名前がついており，東京リージョンの場合だと<strong>ap-northeast-1[a|c|d]</strong>と呼ばれます．</p>
<hr>
<h1 id="3-AWSアカウントとアベイラビリティーゾーン名の関係性"><a href="#3-AWSアカウントとアベイラビリティーゾーン名の関係性" class="headerlink" title="3. AWSアカウントとアベイラビリティーゾーン名の関係性"></a>3. AWSアカウントとアベイラビリティーゾーン名の関係性</h1><p>さて，ここからが本題です．<br>AWSの公式ベージにAZに関して興味深い説明がありました．</p>
<p><strong>アベイラビリティーゾーンは、リージョンコードとそれに続く文字識別子によって表されます(us-east-1a など)。</strong><br><strong>リソースがリージョンの複数のアベイラビリティーゾーンに分散されるようにするため、アベイラビリティーゾーンは各AWSアカウントの名前に個別にマップされます。</strong><br><strong>たとえば、ご使用のAWSアカウントのアベイラビリティーゾーンus-east-1aは別のAWSアカウントのアベイラビリティーゾーンus-east-1aと同じ場所にはない可能性があります。</strong></p>
<p>何を言ってるか分かりますか？<br>「Aさんのus-east-1aと Bさんのus-east-1aは異なる可能性があるよ．なぜなら，各AZの使用リソースが偏らないようにするためだ．」と言っています．<br>ユーザは無意識のうちに若い番号のAZから利用する可能性が高く，AWSはAZごとのリソースの偏りを恐れたのでしょうね．</p>
<p>では，AさんとBさんが同一のAZにシステムを作る方法はないのでしょうか．<br>AWSの公式には，次のようにあります．</p>
<p><strong>アカウント間でアベイラビリティーゾーンを調整するには、アベイラビリティーゾーンの一意で一貫性のある識別子であるAZ IDを使用する必要があります．</strong></p>
<p>つまり，異なるアカウントで同一のAZを利用したい場合，AZ IDを合わせることで実現できそうです．</p>
<hr>
<h1 id="4-おわりに"><a href="#4-おわりに" class="headerlink" title="4. おわりに"></a>4. おわりに</h1><p>今日は，AWS小ネタでした．<br>次回のAWSネタとして，CloudFormation か DNS周り か WorkSpacesの説明を予定しています．<br>早くアップロードできるように頑張りますb<br>ではノシ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/04/16/AWSアカウントとアベイラビリティーゾーン名/" data-id="cjx7ojxkn00028vuyzeq7qbu4" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AWS/">AWS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小ネタ/">小ネタ</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Javascriptの罠-値渡しと参照渡し-" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/09/Javascriptの罠-値渡しと参照渡し-/" class="article-date">
  <time datetime="2019-04-09T11:00:00.000Z" itemprop="datePublished">2019-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/09/Javascriptの罠-値渡しと参照渡し-/">Javascriptの罠 〜値渡しと参照渡し〜</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>こんなタイトルつけたら，Brendan Eich氏に怒られてしまいそうですね苦笑<br>今日は，筆者がJavascriptの仕様をキチンと理解していなかったために発生したトラブルについて紹介します．<br>それでは行きましょう！</p>
<hr>
<h1 id="2-値渡し-と-参照渡し"><a href="#2-値渡し-と-参照渡し" class="headerlink" title="2. 値渡し と 参照渡し"></a>2. 値渡し と 参照渡し</h1><p>値渡しとは，変数間で値のみを渡すことを指し，<br>参照渡しとは，変数間でメモリ上のアドレスを渡すことを指します(参照渡しすると，それぞれの変数が同一のアドレスを指す)．<br>Javascriptにも値渡しと参照渡しがありますが，みなさん意識して使い分けられていますか？　どうでしょうか？</p>
<p>本ブログの結論でもあるのですが，実は意識して使い分ける必要はありません．<br>Javascriptにおいては，<br>　 <strong>変数間の値代入において，プリミティブ型は値渡しとなり，オブジェクト型は参照渡し</strong><br>となります．</p>
<p>「うんうん．そうだよね！」と思われた方は，これ以降は目を通す必要はありません．ブラウザの戻るボタンを押しましょう．</p>
<p>理解していない方，一緒に勉強していきましょう！<br>以下のプログラムをみてください．<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 値渡しの例 */</span> </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 値渡し</span></span><br><span class="line">a = b; </span><br><span class="line"></span><br><span class="line">a++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>上記は，Javascriptで”値渡し”をした例です．<br>5行目を見ると，変数bを変数aに代入しています．変数bはプリミティブ型な値のため，変数bの値が変数aに渡されています．<br>その後7行目で変数aはインクリメントされていますが，もちろん変数aに対する処理が変数bに影響を与えることがないため，<br>それぞれの変数は異なる値となります．</p>
<p>しかし，参照渡しでは動作が異なります．<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 参照渡しの例 */</span> </span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="keyword">var</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参照渡し</span></span><br><span class="line">a = b; </span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [5, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [5, 5, 6]</span></span><br></pre></td></tr></table></figure></p>
<p>上記は，Javascriptで”参照渡し”をした例です．<br>先ほどの例と同様，5行目で変数bを変数aに代入しています．<br>しかし変数bはオブジェクト型の値であるため，先ほどとは異なり変数bのアドレスが変数aに渡されていることに注意です．<br>なので，7行目で変数a[0]をインクリメントしていますが，この処理は処理が変数bにも影響を与えています(変数aと変数bは同一のアドレスを参照しているので)．<br>9行目，10行目でそれぞれの変数を表示させていますが，同一の値が出力されているのが分かります．</p>
<hr>
<h1 id="3-トラブル"><a href="#3-トラブル" class="headerlink" title="3. トラブル"></a>3. トラブル</h1><p>競技プログラミングの中で発生したトラブルを紹介します(筆者はJavascriptで競技プログラミングに参戦しております)．<br>筆者は以下のように，入力で関数の処理を分岐させ配列aに対して異なる処理をしようとしました．<br>※プログラムは簡略化しております．<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result_x = execute(a,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> result_y = execute(a,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(result_x, result_y));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">array,i</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// iが0の時の，arrayに対する処理</span></span><br><span class="line">    <span class="keyword">if</span>(i === <span class="number">0</span>)&#123; a[<span class="number">0</span>]++ &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iが1の時の，arrayに対する処理</span></span><br><span class="line">    <span class="keyword">if</span>(i === <span class="number">1</span>)&#123; a[<span class="number">0</span>]++; a[<span class="number">0</span>]++; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>筆者は，上記のプログラムで配列aが値渡しされていると勘違いしていたため，<br>3行目と4行目で配列aの要素に変化はないと考えていました．<br>しかしこの場合Javascriptでは参照渡しとなるため，3行目と4行目で配列aの要素が異なります．<br>結果，正しい解が表示されず苦しみました苦笑</p>
<hr>
<h1 id="4-おわりに"><a href="#4-おわりに" class="headerlink" title="4. おわりに"></a>4. おわりに</h1><p>Javascriptでも配列の値渡ししたいなぁというのが，筆者の感想です．<br>なんとかなりませんかね(遠い目)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/04/09/Javascriptの罠-値渡しと参照渡し-/" data-id="cjx7ojxkw000a8vuyyie6ty3y" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/トラブル/">トラブル</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CloudFormation-1-テンプレートを書いてみた" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/08/CloudFormation-1-テンプレートを書いてみた/" class="article-date">
  <time datetime="2019-04-08T10:45:00.000Z" itemprop="datePublished">2019-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/08/CloudFormation-1-テンプレートを書いてみた/">CloudFormation(1) 〜テンプレートを書いてみた〜</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>AWSの資格をとって約3ヶ月弱経ったわけですが，特にAWSに触れることなく過ぎ去ってしまいました．<br>なので，リハビリ？ではないですが，今日はAWSに関して触れていきます．<br>今日のテーマはAWSのプロビジョニングツール CloudFormationです！<br>※筆者もCloudFormationに関しては完全なる初心者なので，手探り状態ですがご了承のほどよろしくお願いします．</p>
<hr>
<h1 id="2-ドキュメントを眺めながら手を動かしてみた"><a href="#2-ドキュメントを眺めながら手を動かしてみた" class="headerlink" title="2. ドキュメントを眺めながら手を動かしてみた"></a>2. ドキュメントを眺めながら手を動かしてみた</h1><p>AWSのドキュメントと言えば，BlackBeltが有名です．<br>各ソリューションの概要が適切にまとめられており，勉強するには最適です．<br>リンク貼っておきます↓<br><strong><a href="https://aws.amazon.com/jp/aws-jp-introduction/aws-jp-webinar-service-cut/" target="_blank" rel="noopener">https://aws.amazon.com/jp/aws-jp-introduction/aws-jp-webinar-service-cut/</a></strong></p>
<h2 id="2-1-CloudFormtionの用途"><a href="#2-1-CloudFormtionの用途" class="headerlink" title="2.1. CloudFormtionの用途"></a>2.1. CloudFormtionの用途</h2><p>AWSには様々なデプロイツール/プロビジョニングツールが用意されていますが，<br>CloudFormationの立ち位置は，<strong>AWSのネットワーク構築や各インスタンスの配置，セキュリティ等，マネジメントコンソールから実施できる作業の自動化</strong>になります．</p>
<p>その他のデプロイツールとその立ち位置に関しては，BlackBelt資料に記載があるのでこちらを参照ください．<br><strong><a href="https://www.slideshare.net/AmazonWebServicesJapan/aws-black-belt-online-seminar-aws-cloudformation/12" target="_blank" rel="noopener">https://www.slideshare.net/AmazonWebServicesJapan/aws-black-belt-online-seminar-aws-cloudformation/12</a></strong></p>
<p>※別途機会を設けて，CloudFormation以外の紹介もできたらとも思っております．</p>
<h2 id="2-2-CloudFormtionテンプレート"><a href="#2-2-CloudFormtionテンプレート" class="headerlink" title="2.2. CloudFormtionテンプレート"></a>2.2. CloudFormtionテンプレート</h2><p>AWSのサービスを自動的にプロビジョニングするためには，<br>プロビジョニング方法を規定した”基盤の設計書”を事前に用意する必要があります．<br>CloudFormationでは，当該設計書をテンプレートと呼び，json または yamlで記載します．</p>
<p>テンプレートの記載可能な内容は以下の通りです．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AWSTemplateFormatVersion: &quot;version date&quot; // テンプレートバージョン記載</span><br><span class="line">Description:   // テンプレート説明文を記載</span><br><span class="line">Resources:     // EC2やRDSなどAWSのリソースとプロパティ(必須項目)</span><br><span class="line">Parameters:    // インスタンスサイズ，ユーザ名等 ユーザに入力されるパラメータ</span><br><span class="line">Metadata:      // テンプレートに関する付加情報</span><br><span class="line">Mappings:      // キーと値のマッピング</span><br><span class="line">Condition:     // 条件名と条件判断内容</span><br><span class="line">Transform:     // サーバレスアプリケーションの場合，使用するSAMのバージョンを指定</span><br><span class="line">Outputs:       // デプロイ後にCloudFormationから出力させる値</span><br></pre></td></tr></table></figure></p>
<p>今日はこのなかで，<strong>Resources, Parameters</strong>に関してみていきます(他の項目は，まだ理解していない汗)．</p>
<h3 id="2-2-1-Resources"><a href="#2-2-1-Resources" class="headerlink" title="2.2.1 Resources"></a>2.2.1 Resources</h3><p>Resourcesには，プロビジョニング対象のAWSのリソース情報(VPC，インスタンス，RDS等)を記載します(必須記載項目です！)．<br>記載内容は，インスタンスのサイズ(t2.micro等)やIP，VPCに割り当てるのアドレスなど，多岐に渡ります．<br>具体例をみていきましょう．ここではyamlで記載したテンプレートを紹介します．</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">AWSTemplateFormatVersion:</span> <span class="number">2010</span><span class="bullet">-09</span><span class="bullet">-09</span></span><br><span class="line"><span class="attr">Resources:</span></span><br><span class="line"><span class="attr">  MyVPC:</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="string">'AWS::EC2::VPC'</span></span><br><span class="line"><span class="attr">    Properties:</span></span><br><span class="line"><span class="attr">      CidrBlock:</span> <span class="number">10.100</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line"><span class="attr">      EnableDnsSupport:</span> <span class="string">'true'</span></span><br><span class="line"><span class="attr">      EnableDnsHostnames:</span> <span class="string">'true'</span></span><br></pre></td></tr></table></figure>
<p>上記は，CloudFormationでVPCを作成するテンプレートです．<br>Resources識別子の以下に，VPCに関する詳細情報が記載されてます．<br>1行ずつみていきます．</p>
<ul>
<li>1行目: テンプレートのバージョンを規定しています</li>
<li>2行目: これ以降にリソースを記載する と宣言しています．</li>
<li>3行目: 論理IDを指定しています．</li>
<li>4行目: リソースタイプを指定します．ここではVPCを指定しています．</li>
<li>5行目: これ以降にリソースプロパティを記載する と宣言しています．</li>
<li>6行目: VPCのCidrBlockを指定しています．</li>
<li>7行目: VPC内でDNSを利用有無を指定しています．</li>
<li>8行目: VPC内のインスタンスがDNSホスト名を取得するように指定しています．</li>
</ul>
<p>※論理ID: テンプレート内で利用する識別子です．他のリソース設定で本リソース情報を利用する場合は，論理IDを指定します．</p>
<h3 id="2-2-2-Parameters"><a href="#2-2-2-Parameters" class="headerlink" title="2.2.2 Parameters"></a>2.2.2 Parameters</h3><p>Parameterには，テンプレート内に変数を持ちたい場合に利用されます．<br>例えば，プロビジョニングの度にVPCのCidrBlockを変更したい場合，その都度テンプレートを書き換えるのは非効率です．<br>バグの温床になる可能性もあります．<br>このような場合，VPCのCidrBlockを変数(Parameters)として定義することで，プロビジョニングの度にCidrBlockを変更することが可能です．<br>具体例を見ていきます．</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">AWSTemplateFormatVersion:</span> <span class="number">2010</span><span class="bullet">-09</span><span class="bullet">-09</span></span><br><span class="line"><span class="attr">Parameters:</span></span><br><span class="line"><span class="attr">  VPCcidr:</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="string">String</span></span><br><span class="line"><span class="attr">    Default:</span> <span class="number">10.100</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line"><span class="attr">    AllowedPattern:</span> <span class="string">'(\d&#123;1,3&#125;)\.(\d&#123;1,3&#125;)\.(\d&#123;1,3&#125;)\.(\d&#123;1,3&#125;)/(\d&#123;1,2&#125;)'</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">Resources:</span></span><br><span class="line"><span class="attr">  MyVPC:</span></span><br><span class="line"><span class="attr">    Type:</span> <span class="string">'AWS::EC2::VPC'</span></span><br><span class="line"><span class="attr">    Properties:</span></span><br><span class="line"><span class="attr">      CidrBlock:</span> <span class="type">!Ref</span> <span class="string">VPCcidr</span></span><br><span class="line"><span class="attr">      EnableDnsSupport:</span> <span class="string">'true'</span></span><br><span class="line"><span class="attr">      EnableDnsHostnames:</span> <span class="string">'true'</span></span><br></pre></td></tr></table></figure>
<p>上記は，CloudFormationでVPCを作成するテンプレートです．<br>先ほどの例と異なり，今回はVPCのCidrBlockを変数化しています．<br>1行ずつみていきます．</p>
<ul>
<li>2行目: これ以降にパラメータを記載する と宣言しています</li>
<li>3行目: 論理IDを指定しています．</li>
<li>4行目: 入力タイプStringを指定しています．</li>
<li>5行目: CidrBlockのデフォルト値を指定しています．</li>
<li>6行目: デフォルトから入力を変更する場合，許可する入力パターンを指定しています．</li>
<li>12行目: VPCのCidrBlockに関してはParameterを参照しています．Ref関数を利用します．</li>
</ul>
<p>上記の2つの例(yaml)は，CloudFormationに食わせることでVPCを作成することができます．<br>ぜひ試してみてください！</p>
<hr>
<h1 id="3-おわりに"><a href="#3-おわりに" class="headerlink" title="3. おわりに"></a>3. おわりに</h1><p>今日は，CloudFormationのテンプレートのResorces識別子とParameters識別子に関して記載しました．<br>次回(以降？)は，その他の識別子に関しても記事にできればと思っております．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/04/08/CloudFormation-1-テンプレートを書いてみた/" data-id="cjx7ojxkr00058vuywzxkthr2" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AWS/">AWS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CloudFormation/">CloudFormation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-競技プログラミングと計算量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/競技プログラミングと計算量/" class="article-date">
  <time datetime="2019-04-03T14:00:00.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/競技プログラミングと計算量/">競技プログラミングと計算量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-はじめに"><a href="#1-はじめに" class="headerlink" title="1. はじめに"></a>1. はじめに</h1><p>競技プログラミング歴2ヶ月の筆者です．こんにちは！<br>まだまだ初心者ではありますが，今日は競技プログラミングで求められる計算量について，書いていこうと思います．<br>それではいきましょう！</p>
<hr>
<h1 id="2-O-N-と実行時間"><a href="#2-O-N-と実行時間" class="headerlink" title="2. O(N)と実行時間"></a>2. O(N)と実行時間</h1><p>計算量とはプログラムが実行完了までにかかる計算の量であり，計算の量が多いほど実行完了までに時間がかかると言えます．<br>計算量は<strong>O(x)</strong>の形で記載され，例えばN回のループを実行する以下のプログラムの場合，O(N)の計算量があります．</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    x++;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>さて，競技プログラミングでは実行時間に制限があることが多いと思います．<br>私がお世話になっているAtCoderの場合，多くの問題に<strong>実行時間：2秒</strong>が設定されています．<br>今日は，この2秒以内でどの程度の計算量が実行可能か検証してみたいと思います．</p>
<p>検証は以下の環境で実施します．</p>
<h4 id="検証環境"><a href="#検証環境" class="headerlink" title="検証環境"></a>検証環境</h4><p>・OS: Mojave 10.14.3<br>・CPU: 2.3Ghz Corei5<br>・メモリ: 16GB 2133MHz<br>・Node: v8.10.0</p>
<h4 id="検証プログラム"><a href="#検証プログラム" class="headerlink" title="検証プログラム"></a>検証プログラム</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 開始時間</span></span><br><span class="line"><span class="keyword">const</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> N = <span class="built_in">Math</span>.pow(<span class="number">10</span>, x);</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10^x回だけresultを加算する</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; N; i++) &#123; result++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 終了時間</span></span><br><span class="line"><span class="keyword">const</span> endTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((endTime - startTime)/<span class="number">1000</span>+<span class="string">"s"</span>);</span><br></pre></td></tr></table></figure>
<p>今回は上記のプログラムのxを1から10まで変化させ(ループ回数を変化させ)，その実行時間をそれぞれ5回計測します．<br>そして，5回の平均実行時間をグラフにしました．<br>結果を以下に示します．</p>
<p><img src="/images/20190403-1.png" alt="図1: 計算量と実行時間" title="図1: 計算量と実行時間" width="500"></p>
<p>横軸は計算量，縦軸は計算時間を表しています．<br>グラフを見ると，10^9までは2秒以内に実行が完了するのに対し，10^10では11秒程度実行時間がかかっていることが分かります．<br>このことから，AtCoderの多くの問題では<strong>計算量を10^9以下</strong>に抑える必要がありそうです(10^8以下に抑えることができれば理想的)．</p>
<p>なのでこの性質を利用して，例えばAtCoderの問題で与えられる入力文字列長が10^9以上で場合，「全パターンを探索する可能性は低いな」と邪推することも可能ですw</p>
<h1 id="3-O-x-と計算量"><a href="#3-O-x-と計算量" class="headerlink" title="3. O(x)と計算量"></a>3. O(x)と計算量</h1><p>参考情報扱いですが，<br>以下の計算量のアルゴリズムの入力と計算量の関係を以下に記載します．</p>
<table>
<thead>
<tr>
<th style="text-align:left">O(LogN)</th>
<th style="text-align:left">O(N)</th>
<th style="text-align:left">O(NlogN)</th>
<th style="text-align:left">O(N^2)</th>
<th style="text-align:left">O(2^N)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">3.3</td>
<td style="text-align:left">10</td>
<td style="text-align:left">33</td>
<td style="text-align:left">100</td>
<td style="text-align:left">1024</td>
</tr>
<tr>
<td style="text-align:left">6.6</td>
<td style="text-align:left">100</td>
<td style="text-align:left">660</td>
<td style="text-align:left">10000</td>
<td style="text-align:left">TLE</td>
</tr>
<tr>
<td style="text-align:left">9.9</td>
<td style="text-align:left">1000</td>
<td style="text-align:left">9900</td>
<td style="text-align:left">1000000</td>
<td style="text-align:left">TLE</td>
</tr>
<tr>
<td style="text-align:left">13.2</td>
<td style="text-align:left">10000</td>
<td style="text-align:left">13200</td>
<td style="text-align:left">100000000</td>
<td style="text-align:left">TLE</td>
</tr>
<tr>
<td style="text-align:left">16.6</td>
<td style="text-align:left">100000</td>
<td style="text-align:left">166000</td>
<td style="text-align:left">TLE</td>
<td style="text-align:left">TLE</td>
</tr>
<tr>
<td style="text-align:left">19.9</td>
<td style="text-align:left">1000000</td>
<td style="text-align:left">1990000</td>
<td style="text-align:left">TLE</td>
<td style="text-align:left">TLE</td>
</tr>
<tr>
<td style="text-align:left">23.2</td>
<td style="text-align:left">10000000</td>
<td style="text-align:left">23200000</td>
<td style="text-align:left">TLE</td>
<td style="text-align:left">TLE</td>
</tr>
<tr>
<td style="text-align:left">26.5</td>
<td style="text-align:left">100000000</td>
<td style="text-align:left">TLE?</td>
<td style="text-align:left">TLE</td>
<td style="text-align:left">TLE</td>
</tr>
<tr>
<td style="text-align:left">29.8</td>
<td style="text-align:left">1000000000</td>
<td style="text-align:left">TLE</td>
<td style="text-align:left">TLE</td>
<td style="text-align:left">TLE</td>
</tr>
</tbody>
</table>
<p>※TLE: Time Limit Exceeded<br>※計算量が10^9(実行時間が2秒)以上の場合 TLEと判定します．</p>
<p>表はO(N)を基準に記載されており，例えば N=10の時はO(log10)=3.3と読みます．<br>この表から，O(logN)はNを増加させても計算量がほとんど上昇しないことが分かるかと思います．<br>反対にO(2^N)は一瞬でTLEになるため，全集合2^Nを全探索することは難しいと言うことも分かります．</p>
<p>※もちろん筆者の環境とAtCoderの環境は異なるため，10^9の計算量でTLEになる可能性はあります．ご了承ください．</p>
<hr>
<h1 id="4-おわりに"><a href="#4-おわりに" class="headerlink" title="4. おわりに"></a>4. おわりに</h1><p>本日は，計算量について説明しました．<br>競技プログラミングでTLEになると筆者は悲しい気持ちになります．多分みなさんも同じでしょう．<br>このブログで，少しでも悲しい気持ちになる回数が減れば幸いです．</p>
<p>みなさんも楽しい競技プログラミング生活を送ってくださいね！　では！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kosukeland.github.io/2019/04/03/競技プログラミングと計算量/" data-id="cjx7ojxl7000s8vuymsv23eat" class="article-share-link">共有</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/競技プログラミング/">競技プログラミング</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">次へ &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">タグ</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWS/">AWS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CloudFormation/">CloudFormation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker-for-Windows/">Docker for Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NW/">NW</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/アルゴリズム/">アルゴリズム</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/トラブル/">トラブル</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小ネタ/">小ネタ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/競技プログラミング/">競技プログラミング</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/認定試験/">認定試験</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">タグクラウド</h3>
    <div class="widget tagcloud">
      <a href="/tags/AWS/" style="font-size: 15px;">AWS</a> <a href="/tags/CloudFormation/" style="font-size: 10px;">CloudFormation</a> <a href="/tags/DP/" style="font-size: 10px;">DP</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Docker-for-Windows/" style="font-size: 10px;">Docker for Windows</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Javascript/" style="font-size: 10px;">Javascript</a> <a href="/tags/NW/" style="font-size: 10px;">NW</a> <a href="/tags/アルゴリズム/" style="font-size: 20px;">アルゴリズム</a> <a href="/tags/トラブル/" style="font-size: 12.5px;">トラブル</a> <a href="/tags/小ネタ/" style="font-size: 12.5px;">小ネタ</a> <a href="/tags/競技プログラミング/" style="font-size: 17.5px;">競技プログラミング</a> <a href="/tags/認定試験/" style="font-size: 10px;">認定試験</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">アーカイブ</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最近の投稿</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/22/桁DP実装したった/">桁DP実装したった</a>
          </li>
        
          <li>
            <a href="/2019/05/07/最短経路問題を解く/">最短経路問題を解く</a>
          </li>
        
          <li>
            <a href="/2019/05/01/Dockerネットワークについて/">Dockerネットワークについて</a>
          </li>
        
          <li>
            <a href="/2019/04/20/Docker-for-Windowsと認証プロキシ/">Docker for Windowsと認証プロキシ</a>
          </li>
        
          <li>
            <a href="/2019/04/18/AWSソリューションアーキテクト・アソシエイト試験勉強方法/">AWSソリューションアーキテクト・アソシエイト試験勉強方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Kosuke<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>